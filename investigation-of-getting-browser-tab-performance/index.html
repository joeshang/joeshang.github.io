<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="背景Modern Web Browser 的架构趋势是多进程 Process Per Tab，例如 Chromium（Chrome 或 Edge） 中，每一个 Tab 都对应一个子进程，Safari 虽然不是 Chromium，也是类似的表现。随着 Web Browser 和 Web 技术的发展，越来越多的服务通过 SaaS 或 WebApp 的形式提供，例如 Confluence、Figma 等">
<meta property="og:type" content="article">
<meta property="og:title" content="如何在浏览器外部获取网页的 CPU&#x2F;Memory 和页面加载性能数据">
<meta property="og:url" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/index.html">
<meta property="og:site_name" content="传人的技术博客">
<meta property="og:description" content="背景Modern Web Browser 的架构趋势是多进程 Process Per Tab，例如 Chromium（Chrome 或 Edge） 中，每一个 Tab 都对应一个子进程，Safari 虽然不是 Chromium，也是类似的表现。随着 Web Browser 和 Web 技术的发展，越来越多的服务通过 SaaS 或 WebApp 的形式提供，例如 Confluence、Figma 等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/D7C029BB-55D4-4560-9B87-97BE234F0412.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/8B78E00B-83A5-49A4-A3F6-C71808B6BBA4.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/381A47EE-B7EB-471B-B8A5-729B780BB1B4.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/5C9FBE0C-6AAE-440A-A420-B97FEAF91698.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/63008FDF-EE37-4DA3-B4B8-A791B3F1182E.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/5B4477F9-90A5-4EDA-9439-B725C08BAB42.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/24E76685-25A2-4D8B-BD9D-ECD2BFF838B2.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/17314299888433.jpg">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/FD075D36-92E8-43AE-B8F2-27D877EA58F4.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/6944CFA3-47F5-4EF6-B588-EBC7E1C4015A.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/BA923CE9-F44E-4533-9376-3EA62AB372FC.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/EDB48167-2979-480B-B4B3-07B41195EDB8.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/FAE1F4B3-5EBE-4C41-A8B0-62B9D62409A2.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/609B214F-7144-43E5-89B7-20E0F0482526.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/C3920977-DF8D-4EDB-A090-88E07B8806D9.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/6160143D-CA52-4ED8-8EB1-44833E00933C.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/4D9545FD-FFD9-4630-BD24-16D24611DD3F.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/17314300416677.jpg">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/28B0F088-77B3-453F-931E-EF62305585CB.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/365C3BB0-BDBB-43C8-A43A-0F31B5047F5B.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/44F2F362-E295-40FC-8947-B5EE5E9F2C51.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/420EB00C-9E38-4168-91B0-BE22A1456A6A.png">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/17314301570478.jpg">
<meta property="og:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/17314313062353.jpg">
<meta property="article:published_time" content="2022-11-28T03:34:06.000Z">
<meta property="article:modified_time" content="2024-11-14T14:55:06.857Z">
<meta property="article:author" content="尚传人">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/investigation-of-getting-browser-tab-performance/D7C029BB-55D4-4560-9B87-97BE234F0412.png">

<link rel="canonical" href="http://yoursite.com/investigation-of-getting-browser-tab-performance/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>如何在浏览器外部获取网页的 CPU/Memory 和页面加载性能数据 | 传人的技术博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-67853822-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-67853822-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">传人的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/investigation-of-getting-browser-tab-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          如何在浏览器外部获取网页的 CPU/Memory 和页面加载性能数据
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-28 11:34:06" itemprop="dateCreated datePublished" datetime="2022-11-28T11:34:06+08:00">2022-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-14 22:55:06" itemprop="dateModified" datetime="2024-11-14T22:55:06+08:00">2024-11-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Browser/" itemprop="url" rel="index"><span itemprop="name">Browser</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Modern Web Browser 的架构趋势是<a target="_blank" rel="noopener" href="https://helgeklein.com/blog/modern-multi-process-browser-architecture/">多进程 Process Per Tab</a>，例如 Chromium（Chrome 或 Edge） 中，每一个 Tab 都对应一个子进程，Safari 虽然不是 Chromium，也是类似的表现。随着 Web Browser 和 Web 技术的发展，越来越多的服务通过 SaaS 或 WebApp 的形式提供，例如 Confluence、Figma 等，Web Browser 逐渐成为日常工作中重度使用的平台和资源占用大户。现在的一些监控服务虽然能获取各个进程的 CPU&#x2F;Memory Usage，但是无法监测到到底是哪个 Tab 或 WebApp 耗费的资源比较多，无法更细化的分析 Web Browser 性能。因此，更细化的监控 Web Browser 的性能是个痛点与需求。</p>
<p>Chrome 和 Edge 虽然提供了 Task Manager，可以显示其各个子进程的类型，Tab 当前的 URL，以及其 CPU、Memory 等性能数据，但是很多系统后台性能监控服务无法像用户一样直接打开 OS 内置的 Activity Monitor 等软件查看数据，需要自己通过 API 来获取，因此，我们也需要一种能够在浏览器外部获取每个 Tab 的性能数据，并且要知道对应的 URL 是什么，这样才能方便的定位出到底是哪些 Web App 导致 Browser 消耗了大量性能。</p>
<h2 id="Chrome-技术调研"><a href="#Chrome-技术调研" class="headerlink" title="Chrome 技术调研"></a>Chrome 技术调研</h2><h3 id="Chrome-Extension-API-chrome-processes"><a href="#Chrome-Extension-API-chrome-processes" class="headerlink" title="Chrome Extension API: chrome.processes"></a>Chrome Extension API: chrome.processes</h3><p>首先想到了是 Chrome Extension 是否提供了相关 API 可以获取 Tab 的性能数据：<br><a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/extensions/reference/api/tabs">chrome.tabs</a> 能够访问 Chrome 的 Tab 信息，但其 tabId 是 Chrome 内部使用的，与 pid 没有关系。<br><img src="/investigation-of-getting-browser-tab-performance/D7C029BB-55D4-4560-9B87-97BE234F0412.png"></p>
<p>后来看到了 <a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/extensions/reference/api/processes">chrome.processes</a>，能够通过 tabId 获取对应 Process 的信息，包括 CPU、Memory、pid 等，但遗憾的是，该 API 只能在 Dev Channel 的 Chrome 下执行，正常用户使用的 Stable Channel 的 Chrome 是无法调用此 API 的。<br><img src="/investigation-of-getting-browser-tab-performance/8B78E00B-83A5-49A4-A3F6-C71808B6BBA4.png"></p>
<p>看到 2017 年 Chrome 论坛也有人问：<a target="_blank" rel="noopener" href="https://groups.google.com/a/chromium.org/g/chromium-extensions/c/pyAzuN4neHc">https://groups.google.com/a/chromium.org/g/chromium-extensions/c/pyAzuN4neHc</a> ，于是试试有没有什么 Hack 的方式可以访问 <a target="_blank" rel="noopener" href="https://chromium.googlesource.com/chromium/src/+/main/chrome/common/extensions/api/_permission_features.json">_permission_features.json</a>，从而修改权限，后来发现该文件是 Chrome 编译时候的选项，相当于 Channel 是编译期决议，因此这条路走不通。</p>
<h3 id="Chrome-DevTools-Protocol"><a href="#Chrome-DevTools-Protocol" class="headerlink" title="Chrome DevTools Protocol"></a>Chrome DevTools Protocol</h3><p>Extension 的路走不通，搜索过程中看到了 <a target="_blank" rel="noopener" href="https://chromedevtools.github.io/devtools-protocol/">Chrome DevTools Protocol</a>，是 Chrome 对外开放的一个“远程”调试接口，那通过此接口，能否读取 Chrome 的内部信息呢？读了读文档之后，找到一个 SystemInfo 接口 <a target="_blank" rel="noopener" href="https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/">Chrome DevTools Protocol - SystemInfo domain</a>。</p>
<p>但是也不行，原因是：</p>
<ol>
<li>使用 Chrome DevTools Protocol 需要在启动 Chrome 时，配置 <code>--remote-debug-port=xxx</code> 的参数，用于启动一个 WebSocket 供外部连接，这对于开放调试或者开发者而言还行，对用户来说太不透明。</li>
<li>SystemInfo 中返回的 Process 数据内容太少，虽然有 pid，但是没有 pid 与 Tab 的映射，无法通过 pid 获取 Tab 的信息。</li>
</ol>
<h3 id="逆向-Chrome-内部-IPC-接口"><a href="#逆向-Chrome-内部-IPC-接口" class="headerlink" title="逆向 Chrome 内部 IPC 接口"></a>逆向 Chrome 内部 IPC 接口</h3><p>在搜索 “Get Chrome tab pid” 的过程中，看到回答基本都是使用 Chrome 自带的 Task Manager，提供了每个 Tab 对应的 CPU、Memory、Network、pid 等数据：<br><img src="/investigation-of-getting-browser-tab-performance/381A47EE-B7EB-471B-B8A5-729B780BB1B4.png"></p>
<p>而 Chrome 是多进程架构，进程之间通过 <a target="_blank" rel="noopener" href="https://chromium.googlesource.com/chromium/src/+/master/mojo/README.md">Mojo</a> 进行通信，而 Mojo 比较像 RPC，上层在使用时就如同调用其他进程的 API 一样。而 Chromium 是开源的，能够搜索到 Task Manager 的<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/task_manager/task_manager_interface.h">源码</a>，能否通过模拟 Mojo 的调用，读取 Task Manager 中的数据呢？</p>
<p>首先需要分析一下 Mojo 的数据格式，看到了 <a target="_blank" rel="noopener" href="https://www.mdsec.co.uk/2021/01/breaking-the-browser-a-tale-of-ipc-credentials-and-backdoors/">Breaking The Browser - A tale of IPC, credentials and backdoors - MDSec</a> 和 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=39yPeiY808w">Attacking Chrome IPC</a>，并尝试使用文中使用的 Chrome IPC Sniffer 在 Windows 上进行分析：</p>
<p>刚开始但发现 mojo 的解析失效了，Wireshark 无法分析出来最顶层 mojo 的数据包，导致无法看到 mojo 的具体数据结构：<br><img src="/investigation-of-getting-browser-tab-performance/5C9FBE0C-6AAE-440A-A420-B97FEAF91698.png"><br><img src="/investigation-of-getting-browser-tab-performance/63008FDF-EE37-4DA3-B4B8-A791B3F1182E.png"><br>后来对比了出问题的 lua 文件和 Github 上对应文件，发现在解压时，sniffer 的 lua 插件中文件内容不全，像是解压问题，再次解压后能够读取数据了。</p>
<p>但 mojo 是 Chrome 内部使用的，不稳定，即使这次能够通过逆向 IPC 接口拿到 Task Manager 数据，可一旦 mojo 协议和 Task Manager 相关接口发生变化，就失效了，而且不确定 IPC 调用时未定义的行为会不会导致 Chrome 崩溃。</p>
<h3 id="慢慢确定思路"><a href="#慢慢确定思路" class="headerlink" title="慢慢确定思路"></a>慢慢确定思路</h3><p>到这里仿佛没有路了，在不断搜索中，看到了这个回答：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/63000671/how-would-one-find-the-pid-of-a-browser-extension-running%EF%BC%8C">https://stackoverflow.com/questions/63000671/how-would-one-find-the-pid-of-a-browser-extension-running，</a> <code>ps -ax | grep &#39;Google Chrome Helper&#39; | grep &quot;extension-process&quot;</code> ，是通过分析每个 Chrome 子进程的名字和启动命令行参数得到哪个是 Extension 的，这给我打开了思路，开始仔细分析 ps 出来的 Chrome 子进程的信息：</p>
<blockquote>
<p>63554 ??         0:25.20 &#x2F;Applications&#x2F;Google Chrome.app&#x2F;Contents&#x2F;Frameworks&#x2F;Google Chrome Framework.framework&#x2F;Versions&#x2F;107.0.5304.87&#x2F;Helpers&#x2F;Google Chrome Helper (Renderer).app&#x2F;Contents&#x2F;MacOS&#x2F;Google Chrome Helper (Renderer) –type&#x3D;renderer –display-capture-permissions-policy-allowed –lang&#x3D;en-US –num-raster-threads&#x3D;4 –enable-zero-copy –enable-gpu-memory-buffer-compositor-resources –enable-main-frame-before-activation –renderer-client-id&#x3D;236 –time-ticks-at-unix-epoch&#x3D;-1666552889280259 –launch-time-ticks&#x3D;817765184167 –shared-files –field-trial-handle&#x3D;1718379636,r,13433701468379812598,11346460162339610094,131072 –seatbelt-client&#x3D;204</p>
</blockquote>
<p>分析的规律如下：</p>
<ul>
<li>对于不同类型的进程，Chrome 启动的程序不一样，可以分析出来 Chrome 子进程的类型。<ul>
<li>Tab 和 Extension 是 Google Chrome Helper (Renderer)，type 为 renderer，Extension 会多一个 <code>--extension-process</code> 的参数。</li>
<li>GPU 是 Google Chrome Helper (GPU)。</li>
<li>Utility 是 Google Chrome Helper，type 为 renderer，会有一个 <code>--utility-sub-type</code> 指定 Utility 的具体功能。</li>
<li><code>chrome_crashpad_handler</code> 用于监控 Chrome 的崩溃。</li>
</ul>
</li>
<li>对于 Tab，其启动参数中大部分是相同的，有一个比较特殊，叫 <code>--renderer-client-id</code>，我发现这个 id 每个 Tab 都是唯一的。</li>
</ul>
<p>于是想到一种思路：<strong>通过 ps 能获取到 pid 与 renderer-client-id 的关系，那能否从 Chrome 中拿到 renderer-client-id  与 Tab 的映射关系呢？</strong> 这样的话，Browser 的监控思路就是：</p>
<ul>
<li>通过一定方式，获取 Tab 与 renderer-client-id 的映射，并将 Tab 对应的 URL 发送给 Native 程序。</li>
<li>Native 程序在做进程的性能监控时，对于 Chrome，分析 renderer-client-id 与 pid 映射，通过两者结合，将 URL 与进程的性能信息进行绑定。</li>
</ul>
<p>那如何获取 Tab 与 renderer-client-id 的映射？是下一步的攻关难点。</p>
<h3 id="解析-Chrome-Session-File（SNSS）"><a href="#解析-Chrome-Session-File（SNSS）" class="headerlink" title="解析 Chrome Session File（SNSS）"></a>解析 Chrome Session File（SNSS）</h3><p>Chrome 存在一个 Session File SNSS，当 Chrome 被意外关闭时，可以通过访问该文件恢复所有的 Tab。尝试从这里读取 Tab 信息，但问题是：</p>
<ol>
<li>SNSS 并不是文本文件，需要一个解析器，目前并没有什么稳定的解析器，解析器都是通过逆向写的。</li>
<li>另外，这里只有 URL，没有 Tab 到 pid 的映射。</li>
</ol>
<h3 id="AppleScript-调用-Chrome-接口"><a href="#AppleScript-调用-Chrome-接口" class="headerlink" title="AppleScript 调用 Chrome 接口"></a>AppleScript 调用 Chrome 接口</h3><p>使用 <a target="_blank" rel="noopener" href="https://github.com/prasmussen/chrome-cli">AppleScript 调用 Chrome 提供的接口</a>，不行，列出的 Tab 中 tabId 是内部 ID，和 pid 无法映射。</p>
<h3 id="基于-chrome-process-internals"><a href="#基于-chrome-process-internals" class="headerlink" title="基于 chrome:&#x2F;&#x2F;process-internals"></a>基于 chrome:&#x2F;&#x2F;process-internals</h3><p>Chrome 内置了一些 Scheme 为 chrome 的 URL，通过 chrome:&#x2F;&#x2F;chrome-urls&#x2F; 可以查看，其他浏览器见<a target="_blank" rel="noopener" href="https://www.stefanjudis.com/today-i-learned/how-to-find-all-internal-pages-in-chromiums-and-firefox/">这里</a>，在一个个打开的过程中，发现了 chrome:&#x2F;&#x2F;process-internals，该页面显示所有 Tab 与 Extension 的 FrameTrees：<br><img src="/investigation-of-getting-browser-tab-performance/5B4477F9-90A5-4EDA-9439-B725C08BAB42.png"><br>经过分析，发现 Frame 中第一个数字就是 renderer-client-id，可以通过解析此页面的结果，反查 pid 对应的 URL。但问题是如何在用户无感知的情况下解析获取这个页面的数据呢？</p>
<p>第一个尝试是使用 Chrome 的 <a target="_blank" rel="noopener" href="https://developer.chrome.com/blog/headless-chrome/">headless 模式</a> ，可以无 UI 的使用 Chrome。但一旦 Chrome 启动，无法再次启动一个 Chrome 进程（注意不是窗口），每次调用 Chrome 的二进制都会触发一个新窗口，而使用 headless 相当于和原来的 Chrome 进程互相隔离，是无法通过访问 headless 的 Chrome 获取用户正在使用的 Chrome 的数据的。</p>
<p>第二个尝试是将 chrome:&#x2F;&#x2F;process-internals 页面的源码 Load 下来，在本地加载，避免解析 HTML 页面。在将相关 JS 代码下载后，在 binding.js 中找不到 Mojo 的定义，经过搜索 Chrome 源码，Mojo 是一个全局变量，无法在本地下载的情况下使用：<br><img src="/investigation-of-getting-browser-tab-performance/24E76685-25A2-4D8B-BD9D-ECD2BFF838B2.png"></p>
<h3 id="再次回到-Chrome-Extension-API-chrome-webNavigation"><a href="#再次回到-Chrome-Extension-API-chrome-webNavigation" class="headerlink" title="再次回到 Chrome Extension API: chrome.webNavigation"></a>再次回到 Chrome Extension API: chrome.webNavigation</h3><p>再次绝望，直到搜到了 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36834312/get-chrome-tab-pid-from-chrome-extension">Get Chrome tab pid from Chrome extension - Stack Overflow</a>，里面发现 <a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/extensions/reference/webNavigation/">chrome.webNavigation</a> 可以返回当前 Tab 最顶层 Frame（frameId 为 0）的 processId，而经过对比，发现这个 processId 正是 renderer-client-id！<br>折腾了这么久，终于找到了解决方案：实现一个 Chrome Extension，通过 chrome.tabs 接口遍历所有的 Tab，拿到 tabId 和 URL，再通过 chrome.webNavigation + tabId 获取到 renderer-client-id。</p>
<p><img src="/investigation-of-getting-browser-tab-performance/17314299888433.jpg"></p>
<h3 id="确定方案稳定性"><a href="#确定方案稳定性" class="headerlink" title="确定方案稳定性"></a>确定方案稳定性</h3><p>这个方案虽然可行，且比较 tricky，但是否稳定？让 Chromium 源码为我们证明。</p>
<h4 id="renderer-client-id"><a href="#renderer-client-id" class="headerlink" title="renderer-client-id"></a>renderer-client-id</h4><p>启动参数中的 <code>render-client-id</code>（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/public/common/content_switches.cc?q=renderer-client-id&ss=chromium">源码</a>），2016 年被加入，赋值给 kRendererClientId。</p>
<p>kRendererClientId 在 <code>render-process-host-impl.cc</code> 中使用，AppendRendererCommandLine 将 RenderProcessHostImpl 的 ID 设置为 kRendererClientId（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/renderer_host/render_process_host_impl.cc;l=3271;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/FD075D36-92E8-43AE-B8F2-27D877EA58F4.png"></p>
<p>RenderProcessHostImpl 负责创建和管理渲染子进程，其成员变量 ID 是通过 <code>ChildProcessHostImpl::GenerateChildProcessUniqueId()</code> 生成（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/renderer_host/render_process_host_impl.cc?q=GenerateChildProcessUniqueId&ss=chromium">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/6944CFA3-47F5-4EF6-B588-EBC7E1C4015A.png"></p>
<p>RenderProcessHostImpl 的 Init 会负责启动一个渲染子进程，通过 <code>ChildProcessHost::GetChildPath(flags)</code> 获取 Google Chrome Helper 对应的路径（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/common/child_process_host_impl.cc;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;l=67">源码</a>)，例如 Render 类型会加 Render 后缀，GPU 类型会加 GPU 后缀。</p>
<h4 id="frame-processId"><a href="#frame-processId" class="headerlink" title="frame.processId"></a>frame.processId</h4><p>对于 frame 中的 processId，通过<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:out/Debug/gen/content/browser/resources/process/tsc/process_internals.mojom-webui.js?q=processId&ss=chromium&start=41">源码</a>可以看到，JS binding 调用的是 ProcessInternalsHandler 中的 <code>frame_info-&gt;process_id = frame-&gt;GetProcess()-&gt;GetID();</code>。其中 frame 为 RenderFrameHostImpl，其 GetProcess 返回的是 RenderProcessHost，实际上由 <code>agent_scheduling_group_</code> 返回：<br><img src="/investigation-of-getting-browser-tab-performance/BA923CE9-F44E-4533-9376-3EA62AB372FC.png"></p>
<p>AgentSchedulingGroupHost 在 GetOrCreate 中创建（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/renderer_host/agent_scheduling_group_host.cc;l=104;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/EDB48167-2979-480B-B4B3-07B41195EDB8.png"></p>
<p>AgentSchedulingGroupHost 的 GetOrCreate 被 SiteInstanceGroup 调用（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/site_instance_group.cc;l=24;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/FAE1F4B3-5EBE-4C41-A8B0-62B9D62409A2.png"></p>
<p>SiteInstanceGroup 在 SiteInstanceGroupManager 的 GetOrCreateGroupForNewSiteInstance 中调用（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/site_instance_group_manager.cc;l=49;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/609B214F-7144-43E5-89B7-20E0F0482526.png"></p>
<p>而 GetOrCreateGroupForNewSiteInstance 最终在 SiteInstanceImpl 的 SetProcessInternal 中调用（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/site_instance_impl.cc;l=413;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/C3920977-DF8D-4EDB-A090-88E07B8806D9.png"></p>
<p>而 SetProcessInternal 的 process 参数是 RenderProcessHostImpl 的 GetProcessHostForSiteInstance（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/site_instance_impl.cc;l=375;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/6160143D-CA52-4ED8-8EB1-44833E00933C.png"></p>
<p>兜兜转转，又回到了 RenderProcessHostImpl，因此数据流就通了：</p>
<ol>
<li>RenderProcessHostImpl 负责创建一个渲染子进程，通过 GenerateChildProcessUniqueId 生成一个 ID，并配置到其启动程序的 renderer-client-id 上。</li>
<li>同时 FrameInstance 会绑定一个 RenderProcessHostImpl，其 ID 就是 ProcessId。</li>
</ol>
<p>数据流比较稳定：renderer-client-id 从 16 年就有了，一直没变过，frame 的 processId 从 14 年就基于 RenderProcessHostImpl 的 GenerateChildProcessUniqueId 了。</p>
<h3 id="Edge"><a href="#Edge" class="headerlink" title="Edge"></a>Edge</h3><p><img src="/investigation-of-getting-browser-tab-performance/4D9545FD-FFD9-4630-BD24-16D24611DD3F.png"></p>
<p>解决了 Chrome，由于 Edge 同样基于 Chromium，因此 Edge 可以直接加载 Chrome 的 Extension，另外，Edge 每个 Tab 的子进程的启动参数中也有 renderer-client-id，所以，Edge 的方案与 Chrome 基本一致：</p>
<ul>
<li>Edge 的子进程前缀是 Microsoft Edge。</li>
<li>Edge 会有 PrerenderTab，在启动参数中含有  <code>--instant-process</code>。</li>
</ul>
<p><img src="/investigation-of-getting-browser-tab-performance/17314300416677.jpg"></p>
<p>确定了整体方案，还需要验证：</p>
<ol>
<li>能否通过代码方式，获取一个 pid 对应进程的命令行启动参数。</li>
<li>Extension 如何与 Native App 进行通信。</li>
</ol>
<h3 id="获取-Process-的命令行参数"><a href="#获取-Process-的命令行参数" class="headerlink" title="获取 Process 的命令行参数"></a>获取 Process 的命令行参数</h3><p>对于 Windows，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6520428/how-to-query-a-running-process-for-its-parameters-list-windows-c/6522047">How to query a running process for its parameters list? (Windows, C++)</a> 和 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/21945606/how-can-i-get-the-full-command-line-of-all-the-processes-after-doing-a-process-w">c - How can I get the full command line of all the processes after doing a process walk of the snapshot? - Stack Overflow</a>，效果如下：<br><img src="/investigation-of-getting-browser-tab-performance/28B0F088-77B3-453F-931E-EF62305585CB.png"></p>
<p>对于 Mac，参考 <a target="_blank" rel="noopener" href="https://chromium.googlesource.com/crashpad/crashpad/+/refs/heads/master/util/posix/process_info_mac.cc">Chromium 源码中的 process_info_mac.cc</a>，效果如下：<br><img src="/investigation-of-getting-browser-tab-performance/365C3BB0-BDBB-43C8-A43A-0F31B5047F5B.png"></p>
<h3 id="Extension-同-Native-App-通信"><a href="#Extension-同-Native-App-通信" class="headerlink" title="Extension 同 Native App 通信"></a>Extension 同 Native App 通信</h3><p>搜了一些文章</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://textslashplain.com/2020/09/04/web-to-app-communication-the-native-messaging-api/">Web-to-App Communication: The Native Messaging API – text&#x2F;plain</a></li>
<li><a target="_blank" rel="noopener" href="https://textslashplain.com/2019/08/28/browser-architecture-web-to-app-communication-overview/">Browser Architecture: Web-to-App Communication Overview – text&#x2F;plain</a></li>
<li><a target="_blank" rel="noopener" href="https://learning.postman.com/docs/sending-requests/capturing-request-data/interceptor/">https://learning.postman.com/docs/sending-requests/capturing-request-data/interceptor/</a></li>
</ul>
<p>主流就是两种思路：一个是通过 WebSocket，一个是基于 Chrome 提供的 Native Messaging</p>
<ul>
<li>WebSocket 的问题在于在 Extension 中是否有权限可以访问一个 WebSocket 服务器，且这个服务器是否要求必须是 wss，本地服务器的 ssl 证书不太好弄，另外安全性上风险也高一些。</li>
<li>Native Messaging 看起来更合适一些，因为需求中数据传输量并不大，而且相对安全性好。</li>
</ul>
<h2 id="Native-Messaging-技术调研"><a href="#Native-Messaging-技术调研" class="headerlink" title="Native Messaging 技术调研"></a>Native Messaging 技术调研</h2><p>在调试 Native Messaging 过程中发现以下问题：</p>
<ol>
<li>Host 端不能使用任何 cout 输出，否则调试不通。如果要调试，只能输出到 cerr。</li>
<li>Host 端是由 Chrome 启动的，自己启动没有用，Chrome 只与自己启动的那一份进程通信。</li>
<li>manifest 中 name 必须为 小写字母 . 和 _，其他均为非法。</li>
<li>manifest 应该放到 <code>~/Library/Application Support/Google/Chrome/NativeMessagingHosts</code> 目录。</li>
<li>manifest 的名字应该与 name 一致，为 name.json。</li>
</ol>
<p>因此，Native Service 不适合作为 Extension 的 NativeMessagingHost，需要想办法，有两种方式：</p>
<ol>
<li>Extension 通过 WebSocket 连接到 NativeService。</li>
<li>Extension 与 NativeService 实现一个 Proxy，用于 Extension 调用并中转消息。</li>
</ol>
<p>对于 1，问题是：</p>
<ul>
<li>没有找到一个案例这样用。</li>
<li>Chrome 本身对 WebSocket 的限制，例如需要使用 wss 而不是 ws。</li>
<li>NativeService 配置 ssl 证书私钥感觉不安全。</li>
<li>WebSocket 服务的端口号可能被占用，因此 1 不太合适。</li>
</ul>
<p>对于 2，有以下方案：</p>
<ul>
<li>使用数据库：Proxy 收到数据后写入数据库，问题是通信是单向的，Ao Zhang 的经验看，在 Windows 上使用数据库不太稳，总有各种各样问题。</li>
<li>使用 JSON 文件：Proxy 写入，NativeService 读取，问题是通信是单向的，且读写频率不好同步。</li>
<li>使用进程间通信（Windows 是 Named Pipe，Mac 是 Unix Domain Socket）：成熟的方案，双向通信，比较稳妥。</li>
</ul>
<p>基于此，架构改变为：<strong>增加一个 Extension Helper 作为 Proxy，负责接收 Extension 的数据，通过 IPC 接口转发给 Native Service</strong>。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/extensions/reference/runtime/#method-connectNative">https://developer.chrome.com/docs/extensions/reference/runtime/#method-connectNative</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/apps/nativeMessaging/">https://developer.chrome.com/docs/apps/nativeMessaging/</a></li>
<li><a target="_blank" rel="noopener" href="https://discourse.mozilla.org/t/webextension-with-native-messaging-c-app-side/30821">WebExtension with Native messaging C++ App side - Development - Mozilla Discourse</a></li>
</ul>
<h2 id="Safari-技术调研"><a href="#Safari-技术调研" class="headerlink" title="Safari 技术调研"></a>Safari 技术调研</h2><p>Safari 不是基于 Chromium，而是基于 WebKit 内核：</p>
<ol>
<li>Safari Web Extension 的 API 与 Chrome 不一样，查看其 API 文档，找到 SFSafariPage 有 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/safariservices/sfsafaripage/1639510-getpropertieswithcompletionhandl">getPropertiesWithCompletionHandler(_:)</a> 方法，可以获取 Page Property，但是 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/safariservices/sfsafaripageproperties">SFSafariPageProperties</a> 中只有 title 和 url，没有其他信息。</li>
<li>Safari 虽然每个 Tab 也是对应一个进程，名称为 com.apple.WebKit.WebContent，但是并没有什么启动参数。</li>
</ol>
<p>尝试搜了 Safari Web Extension 有没有什么私有 API 可以访问，在 Apple Runtime Headers 中搜了下 <a target="_blank" rel="noopener" href="https://github.com/LeoNatan/Apple-Runtime-Headers/blob/5e50ad05dfd7d7b69fc2e0e685765fc054166b3c/macOS/PrivateFrameworks/Safari.framework/BrowserTabPersistentState.h">macOS&#x2F;PrivateFrameworks&#x2F;Safari.framework&#x2F;BrowserTabPersistentState.h</a>，没有什么可以用的数据。</p>
<p>Safari 可以通过  <code>defaults write com.apple.Safari IncludeInternalDebugMenu  -bool true</code> 打开 Debug 模式，在选项中将 Tab 对于的 pid 显示在 Tab 标题上。</p>
<p>后来又仔细观察了 Activity Monitor，发现 Safari 对应 Tab 的子进程，能够显示对应 Tab 的 Host URL，于是就想到了：能不能逆向 Activity Monitor，看他到底是怎么实现的。</p>
<h3 id="如何显示-Tab-的-URL"><a href="#如何显示-Tab-的-URL" class="headerlink" title="如何显示 Tab 的 URL"></a>如何显示 Tab 的 URL</h3><p>由于 Safari 使用的是 WebKit，每个 Tab 对应是 WebContents，在用 Hopper 加载 Activity Monitor 之后，开始针对 WebContents&#x2F;WebKit 进行搜索，找到了一个可疑方法，对方法进行反汇编后，定位到一个关键函数调用<code>_LSCopyApplicationInformationItem</code> 和 <code>LSActivePageUserVisibleOriginsKey</code>：</p>
<p><img src="/investigation-of-getting-browser-tab-performance/44F2F362-E295-40FC-8947-B5EE5E9F2C51.png"></p>
<p>用其进行 Google 搜索，找到了以下的参考代码：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/zorgiepoo/d751cba19a0167a589a2">https://gist.github.com/zorgiepoo/d751cba19a0167a589a2</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rodionovd/RDProcess">https://github.com/rodionovd/RDProcess</a></li>
</ul>
<p>在配合 <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/WebKit2/WebKit2-7607.2.6.1.1/WebProcess/cocoa/WebProcessCocoa.mm.auto.html">WebKit 源码</a>，可以看到在 WebProcess 设置名称时，会通过 <code>_LSSetApplicationInformationItem</code> 将对应名称设置为 URL。最后，自己写 Demo 验证可行性，也能像 Activity Monitor 一样显示 Tab 对应 pid 的 Host URL 了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kLSActivePageUserVisibleOriginsKey = <span class="built_in">CFSTR</span>(<span class="string">&quot;LSActivePageUserVisibleOriginsKey&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kLSDisplayName = <span class="built_in">CFSTR</span>(<span class="string">&quot;LSDisplayName&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="type">int</span> kLSMagicConstant = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFTypeRef</span> _LSCopyApplicationInformationItem(<span class="type">int</span> <span class="comment">/* hopefully */</span>, <span class="built_in">CFTypeRef</span>, <span class="built_in">CFStringRef</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFTypeRef</span> _LSASNCreateWithPid(<span class="built_in">CFAllocatorRef</span>, pid_t);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *getWebKitActiveURL(pid_t pid) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *url = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CFTypeRef</span> asn = _LSASNCreateWithPid(kCFAllocatorDefault, pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (asn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">id</span> information = <span class="built_in">CFBridgingRelease</span>(_LSCopyApplicationInformationItem(kLSMagicConstant, asn, kLSActivePageUserVisibleOriginsKey));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ([information isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            url = information;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([information isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="built_in">NSArray</span> *array = (<span class="built_in">NSArray</span> *)information;</span><br><span class="line">            <span class="keyword">if</span> (array.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                url = array[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFRelease</span>(asn);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何正确的识别-Safari-的子进程"><a href="#如何正确的识别-Safari-的子进程" class="headerlink" title="如何正确的识别 Safari 的子进程"></a>如何正确的识别 Safari 的子进程</h3><p>Safari 使用的 WebKit，每个 Tab 是 com.apple.WebKit.WebContent 子进程，其  ppid 都是 1（launchd），而且如果有其他 App 使用了 WebKit（WKWebView），其子进程也是 com.apple.WebKit.WebContent，使用 ppid 的话无法和  Safari 的 Tab 区分出来。需要使用私有 API  <code>responsibility_get_pid_responsible_for_pid</code>  才能取到正确的父进程，参考：<a target="_blank" rel="noopener" href="https://apple.stackexchange.com/questions/327290/how-process-hierarchy-works-in-macos">terminal - How process hierarchy works in macOS - Ask Different</a>。</p>
<h3 id="如何显示-Prewarmed-Tab"><a href="#如何显示-Prewarmed-Tab" class="headerlink" title="如何显示 Prewarmed Tab"></a>如何显示 Prewarmed Tab</h3><p>Safari 有 Prewarmed Tab，此 Tab 对应的进程没有 URL，但是 Activity Monitor 能显示对应进程的名称，通过 <code>_LSCopyApplicationInformationItem(kLSMagicConstant, asn, &quot;LSDisplayName&quot;)</code>  获取进程的显示名称。</p>
<h3 id="将现有的-Chrome-Extension-转换成-Safari-Extension"><a href="#将现有的-Chrome-Extension-转换成-Safari-Extension" class="headerlink" title="将现有的 Chrome Extension 转换成 Safari Extension"></a>将现有的 Chrome Extension 转换成 Safari Extension</h3><p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/safariservices/safari_web_extensions/converting_a_web_extension_for_safari?language=objc">Converting a web extension for Safari</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun safari-web-extension-converter --app-name <span class="string">&quot;ArgusSafariHelper&quot;</span> --bundle-identifier <span class="string">&quot;com.argus.safari.helper&quot;</span> --macos-only --copy-resources  ../argus-chromium-extension/extension</span><br></pre></td></tr></table></figure>

<p> Extension 需要处理的有：</p>
<ol>
<li>删除不需要的 webNavigation 和处理权限兼容性：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Browser_compatibility_for_manifest.json">Browser compatibility for manifest.json - Mozilla | MDN</a>。</li>
<li>处理 <all_urls> 的兼容性：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Match_patterns">Match patterns in extension manifests - Mozilla | MDN</a>。</li>
<li>使用 browser 而不是 chrome 访问 Extension API。</li>
</ol>
<h2 id="其他-Browser-技术调研"><a href="#其他-Browser-技术调研" class="headerlink" title="其他 Browser 技术调研"></a>其他 Browser 技术调研</h2><h3 id="Internet-Explorer"><a href="#Internet-Explorer" class="headerlink" title="Internet Explorer"></a>Internet Explorer</h3><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8445742/how-to-get-the-url-of-the-internet-explorer-tabs-with-pid-of-each-tab?rq=1">c# - How to get the URL of the Internet explorer tabs with PID of each tab? - Stack Overflow</a></p>
<h3 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h3><p>Firefox 每个 Tab 对应的子进程有启动参数，也提供了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/webNavigation">webNavigation - Mozilla | MDN</a> 的 API，但是返回的数据中并没有 processId（文档上有），不知道为啥，<a target="_blank" rel="noopener" href="https://github.com/mdn/webextensions-examples#installing-an-example">GitHub - mdn&#x2F;webextensions-examples: Example Firefox add-ons created using the WebExtensions API</a></p>
<p><img src="/investigation-of-getting-browser-tab-performance/420EB00C-9E38-4168-91B0-BE22A1456A6A.png"></p>
<p>不过 Firefox 占有率不高，所以就先不看了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/investigation-of-getting-browser-tab-performance/17314301570478.jpg"></p>
<p>实现需要 Web Extension + Native Service 配合才能实现，同时需要一个 “Proxy” 作为二者通信的中转站，因此架构主要由三块组成：</p>
<ul>
<li>Web Extension：安装在浏览器中，负责获取 Tab 的 Frame 数据和页面加载性能数据<ul>
<li>基于 Chrome Extension API，聚合多个 Event 回调，配合 content.js 中的 PerformanceObserver，生成页面加载性能数据。</li>
<li>遍历 Tab 并通过 webNavigation 获取其 Frame 相关数据。</li>
<li>通过 Native Messaging 与 Extension Helper 建立其连接，并接收和发送消息。</li>
</ul>
</li>
<li>Extension Helper：负责消息转发<ul>
<li>通过 IPC（Windows 是 Named Pipe，Mac 是 Unix Domain Socket）与 Native Service 建立通信，Native Service 是 Server 端。</li>
<li>通过 stdin 从 Web Extension 接收消息，解码后通过 IPC 转发给 Native Service。</li>
<li>通过 IPC 从 Native Service 接收消息，编码后通过 stdout 转发给 Web Extension。</li>
</ul>
</li>
<li>Native Service：负责分析监控 Browser 各个子进程及其性能数据，聚合 Web Extension 数据后上传<ul>
<li>分析各个子进程的启动参数，并通过参数来区分进程类型。</li>
<li>监控各个子进程的 CPU 和 Memory 性能。</li>
<li>从 Web Extension 接收消息，与进程的性能数据聚合。</li>
<li>将页面的 CPU 和 Memory 性能以及页面加载性能上传。</li>
</ul>
</li>
</ul>
<p>最终显示效果如下：<br><img src="/investigation-of-getting-browser-tab-performance/17314313062353.jpg"></p>
<h3 id="实现过程中遇到的坑"><a href="#实现过程中遇到的坑" class="headerlink" title="实现过程中遇到的坑"></a>实现过程中遇到的坑</h3><h4 id="Chromium-Extension"><a href="#Chromium-Extension" class="headerlink" title="Chromium Extension"></a>Chromium Extension</h4><ul>
<li>postMessage 发送 JSON 数据时，要使用 <code>&#123; &quot;key&quot;: value &#125;</code> 的形式，不能 <code>var object = &#123;&#125;; object.key = value</code>，这样会导致 NativeService 端解析 JSON 数据时失败。</li>
<li>使用 Developer Mode 加载 Extension 时，每次重新加载或者换设备都会导致 Extension 的 UUID 变化，可以利用 <code>manifest.json</code> 中的 key 来锁定 Extension 的 UUID，需要申请一个 Chrome WebStore 账号，将 Extension 的 zip 包上传一次，从而获取 PublicKey。</li>
</ul>
<h4 id="Extension-Helper"><a href="#Extension-Helper" class="headerlink" title="Extension Helper"></a>Extension Helper</h4><ul>
<li>在转发数据给 NativeService 时，先发送长度，再发送 JSON 数据。有时候 NativeService 先收到 JSON 数据，导致解析出来的 length 是一个巨大无比的值，在 recv 时越界导致崩溃。后来发现如果长度和数据分两次 send 的话，就会出现这个问题，然后 1 将 NO BLOCK 模式关了，2 将长度和数据合并到一个缓冲区中用一次 send 发送，问题不再出现。</li>
<li>发送数据给 Extension 时，必须用 JSON 包一下，否则 Extension 不识别。</li>
<li>Extension Helper 由 Browser 负责启动，属于 Browser 的子进程，其生命周期和 Extension 中 <code>chrome.runtime.connectNative</code> 返回的 Port 一致，最好持有此 Port，不然每次 <code>chrome.runtime.connectNative</code> 都会创建一个 Extension Helper 子进程。</li>
</ul>
<h4 id="Native-Services"><a href="#Native-Services" class="headerlink" title="Native Services"></a>Native Services</h4><ul>
<li>Unix Domain Socket 会新建一个文件，每次在 bind 前需要用 unlink 删除，不然会导致 bind 失败。</li>
<li>允许非 root 权限程序能够读写 Unix Domain Socket，需要在 bind 前使用 umask，然后在 bind 后恢复。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mask = umask(<span class="number">777</span>);</span><br><span class="line">umask(mask);</span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/ios-classroom-refactor/" rel="prev" title="猿辅导 iOS 直播教室重构之路 —— 教室积木化">
      <i class="fa fa-chevron-left"></i> 猿辅导 iOS 直播教室重构之路 —— 教室积木化
    </a></div>
      <div class="post-nav-item">
    <a href="/dex-jarvis-play-with-openai-api-for-dex-troubleshooting/" rel="next" title="基于 OpenAI Assistant API 与现有 Metrics 工具自动定位和修复 IT 问题的尝试">
      基于 OpenAI Assistant API 与现有 Metrics 工具自动定位和修复 IT 问题的尝试 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chrome-%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94"><span class="nav-number">2.</span> <span class="nav-text">Chrome 技术调研</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Chrome-Extension-API-chrome-processes"><span class="nav-number">2.1.</span> <span class="nav-text">Chrome Extension API: chrome.processes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chrome-DevTools-Protocol"><span class="nav-number">2.2.</span> <span class="nav-text">Chrome DevTools Protocol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E5%90%91-Chrome-%E5%86%85%E9%83%A8-IPC-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.3.</span> <span class="nav-text">逆向 Chrome 内部 IPC 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%85%A2%E7%A1%AE%E5%AE%9A%E6%80%9D%E8%B7%AF"><span class="nav-number">2.4.</span> <span class="nav-text">慢慢确定思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-Chrome-Session-File%EF%BC%88SNSS%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">解析 Chrome Session File（SNSS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AppleScript-%E8%B0%83%E7%94%A8-Chrome-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.6.</span> <span class="nav-text">AppleScript 调用 Chrome 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-chrome-process-internals"><span class="nav-number">2.7.</span> <span class="nav-text">基于 chrome:&#x2F;&#x2F;process-internals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E6%AC%A1%E5%9B%9E%E5%88%B0-Chrome-Extension-API-chrome-webNavigation"><span class="nav-number">2.8.</span> <span class="nav-text">再次回到 Chrome Extension API: chrome.webNavigation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E6%96%B9%E6%A1%88%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-number">2.9.</span> <span class="nav-text">确定方案稳定性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#renderer-client-id"><span class="nav-number">2.9.1.</span> <span class="nav-text">renderer-client-id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#frame-processId"><span class="nav-number">2.9.2.</span> <span class="nav-text">frame.processId</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Edge"><span class="nav-number">2.10.</span> <span class="nav-text">Edge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Process-%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">2.11.</span> <span class="nav-text">获取 Process 的命令行参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Extension-%E5%90%8C-Native-App-%E9%80%9A%E4%BF%A1"><span class="nav-number">2.12.</span> <span class="nav-text">Extension 同 Native App 通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Native-Messaging-%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94"><span class="nav-number">3.</span> <span class="nav-text">Native Messaging 技术调研</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Safari-%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94"><span class="nav-number">4.</span> <span class="nav-text">Safari 技术调研</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA-Tab-%E7%9A%84-URL"><span class="nav-number">4.1.</span> <span class="nav-text">如何显示 Tab 的 URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AF%86%E5%88%AB-Safari-%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">如何正确的识别 Safari 的子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA-Prewarmed-Tab"><span class="nav-number">4.3.</span> <span class="nav-text">如何显示 Prewarmed Tab</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E7%8E%B0%E6%9C%89%E7%9A%84-Chrome-Extension-%E8%BD%AC%E6%8D%A2%E6%88%90-Safari-Extension"><span class="nav-number">4.4.</span> <span class="nav-text">将现有的 Chrome Extension 转换成 Safari Extension</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-Browser-%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94"><span class="nav-number">5.</span> <span class="nav-text">其他 Browser 技术调研</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Internet-Explorer"><span class="nav-number">5.1.</span> <span class="nav-text">Internet Explorer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Firefox"><span class="nav-number">5.2.</span> <span class="nav-text">Firefox</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91"><span class="nav-number">6.2.</span> <span class="nav-text">实现过程中遇到的坑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Chromium-Extension"><span class="nav-number">6.2.1.</span> <span class="nav-text">Chromium Extension</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Extension-Helper"><span class="nav-number">6.2.2.</span> <span class="nav-text">Extension Helper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Native-Services"><span class="nav-number">6.2.3.</span> <span class="nav-text">Native Services</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="尚传人"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">尚传人</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/joeshang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;joeshang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shangchuanren@gmail.com" title="E-Mail → mailto:shangchuanren@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/2464216170" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;2464216170" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/bridge_joe" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;bridge_joe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">尚传人</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
