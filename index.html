<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish">
<meta property="og:type" content="website">
<meta property="og:title" content="传人的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="传人的技术博客">
<meta property="og:description" content="Stay Hungry, Stay Foolish">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="尚传人">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>传人的技术博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-67853822-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-67853822-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">传人的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/investigation-of-getting-browser-tab-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/investigation-of-getting-browser-tab-performance/" class="post-title-link" itemprop="url">如何在浏览器外部获取网页的 CPU/Memory 和页面加载性能数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-28 11:34:06" itemprop="dateCreated datePublished" datetime="2022-11-28T11:34:06+08:00">2022-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-14 21:01:26" itemprop="dateModified" datetime="2024-11-14T21:01:26+08:00">2024-11-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Browser/" itemprop="url" rel="index"><span itemprop="name">Browser</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Modern Web Browser 的架构趋势是<a target="_blank" rel="noopener" href="https://helgeklein.com/blog/modern-multi-process-browser-architecture/">多进程 Process Per Tab</a>，例如 Chromium（Chrome 或 Edge） 中，每一个 Tab 都对应一个子进程，Safari 虽然不是 Chromium，也是类似的表现。随着 Web Browser 和 Web 技术的发展，越来越多的服务通过 SaaS 或 WebApp 的形式提供，例如 Confluence、Figma 等，Web Browser 逐渐成为日常工作中重度使用的平台和资源占用大户。现在的一些监控服务虽然能获取各个进程的 CPU&#x2F;Memory Usage，但是无法监测到到底是哪个 Tab 或 WebApp 耗费的资源比较多，无法更细化的分析 Web Browser 性能。因此，更细化的监控 Web Browser 的性能是个痛点与需求。</p>
<p>Chrome 和 Edge 虽然提供了 Task Manager，可以显示其各个子进程的类型，Tab 当前的 URL，以及其 CPU、Memory 等性能数据，但是很多系统后台性能监控服务无法像用户一样直接打开 OS 内置的 Activity Monitor 等软件查看数据，需要自己通过 API 来获取，因此，我们也需要一种能够在浏览器外部获取每个 Tab 的性能数据，并且要知道对应的 URL 是什么，这样才能方便的定位出到底是哪些 Web App 导致 Browser 消耗了大量性能。</p>
<h2 id="Chrome-技术调研"><a href="#Chrome-技术调研" class="headerlink" title="Chrome 技术调研"></a>Chrome 技术调研</h2><h3 id="Chrome-Extension-API-chrome-processes"><a href="#Chrome-Extension-API-chrome-processes" class="headerlink" title="Chrome Extension API: chrome.processes"></a>Chrome Extension API: chrome.processes</h3><p>首先想到了是 Chrome Extension 是否提供了相关 API 可以获取 Tab 的性能数据：<br><a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/extensions/reference/api/tabs">chrome.tabs</a> 能够访问 Chrome 的 Tab 信息，但其 tabId 是 Chrome 内部使用的，与 pid 没有关系<br><img src="/investigation-of-getting-browser-tab-performance/D7C029BB-55D4-4560-9B87-97BE234F0412.png"></p>
<p>后来看到了 <a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/extensions/reference/api/processes">chrome.processes</a>，能够通过 tabId 获取对应 Process 的信息，包括 CPU、Memory、pid 等，但遗憾的是，该 API 只能在 Dev Channel 的 Chrome 下执行，正常用户使用的 Stable Channel 的 Chrome 是无法调用此 API 的。<br><img src="/investigation-of-getting-browser-tab-performance/8B78E00B-83A5-49A4-A3F6-C71808B6BBA4.png"></p>
<p>看到 2017 年 Chrome 论坛也有人问：<a target="_blank" rel="noopener" href="https://groups.google.com/a/chromium.org/g/chromium-extensions/c/pyAzuN4neHc%EF%BC%8C%E4%BA%8E%E6%98%AF%E8%AF%95%E8%AF%95%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88">https://groups.google.com/a/chromium.org/g/chromium-extensions/c/pyAzuN4neHc，于是试试有没有什么</a> Hack 的方式可以访问 <a target="_blank" rel="noopener" href="https://chromium.googlesource.com/chromium/src/+/main/chrome/common/extensions/api/_permission_features.json">_permission_features.json</a>，从而修改权限，后来发现该文件是 Chrome 编译时候的选项，相当于 Channel 是编译期决议，因此这条路走不通</p>
<h3 id="Chrome-DevTools-Protocol"><a href="#Chrome-DevTools-Protocol" class="headerlink" title="Chrome DevTools Protocol"></a>Chrome DevTools Protocol</h3><p>Extension 的路走不通，搜索过程中看到了 <a target="_blank" rel="noopener" href="https://chromedevtools.github.io/devtools-protocol/">Chrome DevTools Protocol</a>，是 Chrome 对外开放的一个“远程”调试接口，那通过此接口，能否读取 Chrome 的内部信息呢？读了读文档之后，找到一个 SystemInfo 接口 <a target="_blank" rel="noopener" href="https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/">Chrome DevTools Protocol - SystemInfo domain</a></p>
<p>但是也不行，原因是：</p>
<ol>
<li>使用 Chrome DevTools Protocol 需要在启动 Chrome 时，配置 <code>--remote-debug-port=xxx</code> 的参数，用于启动一个 WebSocket 供外部连接，这对于开放调试或者开发者而言还行，对用户来说太不透明</li>
<li>SystemInfo 中返回的 Process 数据内容太少，虽然有 pid，但是没有 pid 与 Tab 的映射，无法通过 pid 获取 Tab 的信息</li>
</ol>
<h3 id="逆向-Chrome-内部-IPC-接口"><a href="#逆向-Chrome-内部-IPC-接口" class="headerlink" title="逆向 Chrome 内部 IPC 接口"></a>逆向 Chrome 内部 IPC 接口</h3><p>在搜索 “Get Chrome tab pid” 的过程中，看到回答基本都是使用 Chrome 自带的 Task Manager，提供了每个 Tab 对应的 CPU、Memory、Network、pid 等数据<br><img src="/investigation-of-getting-browser-tab-performance/381A47EE-B7EB-471B-B8A5-729B780BB1B4.png"></p>
<p>而 Chrome 是多进程架构，进程之间通过 <a target="_blank" rel="noopener" href="https://chromium.googlesource.com/chromium/src/+/master/mojo/README.md">Mojo</a> 进行通信，而 Mojo 比较像 RPC，上层在使用时就如同调用其他进程的 API 一样。而 Chromium 是开源的，能够搜索到 Task Manager 的<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/task_manager/task_manager_interface.h">源码</a>，能否通过模拟 Mojo 的调用，读取 Task Manager 中的数据呢？</p>
<p>首先需要分析一下 Mojo 的数据格式，看到了 <a target="_blank" rel="noopener" href="https://www.mdsec.co.uk/2021/01/breaking-the-browser-a-tale-of-ipc-credentials-and-backdoors/">Breaking The Browser - A tale of IPC, credentials and backdoors - MDSec</a> 和 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=39yPeiY808w">Attacking Chrome IPC</a>，并尝试使用文中使用的 Chrome IPC Sniffer 在 Windows 上进行分析：</p>
<p>刚开始但发现 mojo 的解析失效了，Wireshark 无法分析出来最顶层 mojo 的数据包，导致无法看到 mojo 的具体数据结构<br><img src="/investigation-of-getting-browser-tab-performance/5C9FBE0C-6AAE-440A-A420-B97FEAF91698.png"><br><img src="/investigation-of-getting-browser-tab-performance/63008FDF-EE37-4DA3-B4B8-A791B3F1182E.png"><br>后来对比了出问题的 lua 文件和 Github 上对应文件，发现在解压时，sniffer 的 lua 插件中文件内容不全，像是解压问题，再次解压后能够读取数据了。</p>
<p>但 mojo 是 Chrome 内部使用的，不稳定，即使这次能够通过逆向 IPC 接口拿到 Task Manager 数据，可一旦 mojo 协议和 Task Manager 相关接口发生变化，就失效了，而且不确定 IPC 调用时未定义的行为会不会导致 Chrome 崩溃。</p>
<h3 id="慢慢确定思路"><a href="#慢慢确定思路" class="headerlink" title="慢慢确定思路"></a>慢慢确定思路</h3><p>到这里仿佛没有路了，在不断搜索中，看到了这个回答：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/63000671/how-would-one-find-the-pid-of-a-browser-extension-running%EF%BC%8C">https://stackoverflow.com/questions/63000671/how-would-one-find-the-pid-of-a-browser-extension-running，</a> <code>ps -ax | grep &#39;Google Chrome Helper&#39; | grep &quot;extension-process&quot;</code> ，是通过分析每个 Chrome 子进程的名字和启动命令行参数得到哪个是 Extension 的，这给我打开了思路，开始仔细分析 ps 出来的 Chrome 子进程的信息：</p>
<blockquote>
<p>63554 ??         0:25.20 &#x2F;Applications&#x2F;Google Chrome.app&#x2F;Contents&#x2F;Frameworks&#x2F;Google Chrome Framework.framework&#x2F;Versions&#x2F;107.0.5304.87&#x2F;Helpers&#x2F;Google Chrome Helper (Renderer).app&#x2F;Contents&#x2F;MacOS&#x2F;Google Chrome Helper (Renderer) –type&#x3D;renderer –display-capture-permissions-policy-allowed –lang&#x3D;en-US –num-raster-threads&#x3D;4 –enable-zero-copy –enable-gpu-memory-buffer-compositor-resources –enable-main-frame-before-activation –renderer-client-id&#x3D;236 –time-ticks-at-unix-epoch&#x3D;-1666552889280259 –launch-time-ticks&#x3D;817765184167 –shared-files –field-trial-handle&#x3D;1718379636,r,13433701468379812598,11346460162339610094,131072 –seatbelt-client&#x3D;204</p>
</blockquote>
<p>分析的规律如下：</p>
<ul>
<li>对于不同类型的进程，Chrome 启动的程序不一样，可以分析出来 Chrome 子进程的类型<ul>
<li>Tab 和 Extension 是 Google Chrome Helper (Renderer)，type 为 renderer，Extension 会多一个 <code>extension-process</code> 的参数</li>
<li>GPU 是 Google Chrome Helper (GPU)</li>
<li>Utility 是 Google Chrome Helper，type 为 render，会有一个 <code>utility-sub-type</code> 指定 Utility 的具体功能</li>
<li><code>chrome_crashpad_handler</code> 用于监控 Chrome 的崩溃</li>
</ul>
</li>
<li>对于 Tab，其启动参数中大部分是相同的，有一个比较特殊，叫 <code>--renderer-client-id</code>，我发现这个 id 每个 Tab 都是唯一的</li>
</ul>
<p>于是想到一种思路：<strong>通过 ps 能获取到 pid 与 renderer-client-id 的关系，那能否从 Chrome 中拿到 renderer-client-id  与 Tab 的映射关系呢？</strong> 这样的话，Browser 的监控思路就是：</p>
<ul>
<li>通过一定方式，获取 Tab 与 renderer-client-id 的映射，并将 Tab 对应的 URL 发送给 Native 程序</li>
<li>Native 程序在做进程的性能监控时，对于 Chrome，分析 renderer-client-id 与 pid 映射，通过两者结合，将 URL 与进程的性能信息进行绑定</li>
</ul>
<p>那如何获取 Tab 与 renderer-client-id 的映射？是下一步的攻关难点</p>
<h3 id="解析-Chrome-Session-File（SNSS）"><a href="#解析-Chrome-Session-File（SNSS）" class="headerlink" title="解析 Chrome Session File（SNSS）"></a>解析 Chrome Session File（SNSS）</h3><p>Chrome 存在一个 Session File SNSS，当 Chrome 被意外关闭时，可以通过访问该文件恢复所有的 Tab。尝试从这里读取 Tab 信息，但问题是：</p>
<ol>
<li>SNSS 并不是文本文件，需要一个解析器，目前并没有什么稳定的解析器，解析器都是通过逆向写的</li>
<li>另外，这里只有 URL，没有 Tab 到 pid 的映射</li>
</ol>
<h3 id="AppleScript-调用-Chrome-接口"><a href="#AppleScript-调用-Chrome-接口" class="headerlink" title="AppleScript 调用 Chrome 接口"></a>AppleScript 调用 Chrome 接口</h3><p>使用 <a target="_blank" rel="noopener" href="https://github.com/prasmussen/chrome-cli">AppleScript 调用 Chrome 提供的接口</a>，不行，列出的 Tab 中 tabId 是内部 ID，和 pid 无法映射</p>
<h3 id="基于-chrome-process-internals"><a href="#基于-chrome-process-internals" class="headerlink" title="基于 chrome:&#x2F;&#x2F;process-internals"></a>基于 chrome:&#x2F;&#x2F;process-internals</h3><p>Chrome 内置了一些 Scheme 为 chrome 的 URL，通过 chrome:&#x2F;&#x2F;chrome-urls&#x2F; 可以查看，其他浏览器见<a target="_blank" rel="noopener" href="https://www.stefanjudis.com/today-i-learned/how-to-find-all-internal-pages-in-chromiums-and-firefox/">这里</a>，在一个个打开的过程中，发现了 chrome:&#x2F;&#x2F;process-internals，该页面显示所有 Tab 与 Extension 的 FrameTrees：<br><img src="/investigation-of-getting-browser-tab-performance/5B4477F9-90A5-4EDA-9439-B725C08BAB42.png"><br>经过分析，发现 Frame 中第一个数字就是 renderer-client-id，可以通过解析此页面的结果，反查 pid 对应的 URL。但问题是如何在用户无感知的情况下解析获取这个页面的数据呢？</p>
<p>第一个尝试是使用 Chrome 的 <a target="_blank" rel="noopener" href="https://developer.chrome.com/blog/headless-chrome/">headless 模式</a> ，可以无 UI 的使用 Chrome。但一旦 Chrome 启动，无法再次启动一个 Chrome 进程（注意不是窗口），每次调用 Chrome 的二进制都会触发一个新窗口，而使用 headless 相当于和原来的 Chrome 进程互相隔离，是无法通过访问 headless 的 Chrome 获取用户正在使用的 Chrome 的数据的。</p>
<p>第二个尝试是将 chrome:&#x2F;&#x2F;process-internals 页面的源码 Load 下来，在本地加载，避免解析 HTML 页面。在将相关 JS 代码下载后，在 binding.js 中找不到 Mojo 的定义，经过搜索 Chrome 源码，Mojo 是一个全局变量，无法在本地下载的情况下使用<br><img src="/investigation-of-getting-browser-tab-performance/24E76685-25A2-4D8B-BD9D-ECD2BFF838B2.png"></p>
<h3 id="再次回到-Chrome-Extension-API-chrome-webNavigation"><a href="#再次回到-Chrome-Extension-API-chrome-webNavigation" class="headerlink" title="再次回到 Chrome Extension API: chrome.webNavigation"></a>再次回到 Chrome Extension API: chrome.webNavigation</h3><p>再次绝望，直到搜到了 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36834312/get-chrome-tab-pid-from-chrome-extension">Get Chrome tab pid from Chrome extension - Stack Overflow</a>，里面发现 <a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/extensions/reference/webNavigation/">chrome.webNavigation</a> 可以返回当前 Tab 最顶层 Frame（frameId 为 0）的 processId，而经过对比，发现这个 processId 正是 renderer-client-id！<br>折腾了这么久，终于找到了解决方案：实现一个 Chrome Extension，通过 chrome.tabs 接口遍历所有的 Tab，拿到 tabId 和 URL，再通过 chrome.webNavigation + tabId 获取到 renderer-client-id</p>
<p><img src="/investigation-of-getting-browser-tab-performance/17314299888433.jpg"></p>
<h3 id="确定方案稳定性"><a href="#确定方案稳定性" class="headerlink" title="确定方案稳定性"></a>确定方案稳定性</h3><p>这个方案虽然可行，且比较 tricky，但是否稳定？让源码为我们证明！</p>
<h4 id="renderer-client-id"><a href="#renderer-client-id" class="headerlink" title="renderer-client-id"></a>renderer-client-id</h4><p>启动参数中的 <code>render-client-id</code>（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/public/common/content_switches.cc?q=renderer-client-id&ss=chromium">源码</a>），2016 年被加入，赋值给 kRendererClientId</p>
<p>kRendererClientId 在 <code>render-process-host-impl.cc</code> 中使用，AppendRendererCommandLine 将 RenderProcessHostImpl 的 ID 设置为 kRendererClientId（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/renderer_host/render_process_host_impl.cc;l=3271;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/FD075D36-92E8-43AE-B8F2-27D877EA58F4.png"></p>
<p>RenderProcessHostImpl 负责创建和管理渲染子进程，其成员变量 ID 是通过 <code>ChildProcessHostImpl::GenerateChildProcessUniqueId()</code> 生成（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/renderer_host/render_process_host_impl.cc?q=GenerateChildProcessUniqueId&ss=chromium">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/6944CFA3-47F5-4EF6-B588-EBC7E1C4015A.png"></p>
<p>RenderProcessHostImpl 的 Init 会负责启动一个渲染子进程，通过 <code>ChildProcessHost::GetChildPath(flags)</code> 获取 Google Chrome Helper 对应的路径（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/common/child_process_host_impl.cc;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;l=67">源码</a>)，例如 Render 类型会加 Render 后缀，GPU 类型会加 GPU 后缀</p>
<h4 id="frame-processId"><a href="#frame-processId" class="headerlink" title="frame.processId"></a>frame.processId</h4><p>对于 frame 中的 processId，通过<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:out/Debug/gen/content/browser/resources/process/tsc/process_internals.mojom-webui.js?q=processId&ss=chromium&start=41">源码</a>可以看到，JS binding 调用的是 ProcessInternalsHandler 中的 <code>frame_info-&gt;process_id = frame-&gt;GetProcess()-&gt;GetID();</code></p>
<p>其中 frame 为 RenderFrameHostImpl，其 GetProcess 返回的是 RenderProcessHost，实际上由 <code>agent_scheduling_group_</code>  返回<br><img src="/investigation-of-getting-browser-tab-performance/BA923CE9-F44E-4533-9376-3EA62AB372FC.png"></p>
<p>AgentSchedulingGroupHost 在 GetOrCreate 中创建（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/renderer_host/agent_scheduling_group_host.cc;l=104;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/EDB48167-2979-480B-B4B3-07B41195EDB8.png"></p>
<p>AgentSchedulingGroupHost 的 GetOrCreate 被 SiteInstanceGroup 调用（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/site_instance_group.cc;l=24;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/FAE1F4B3-5EBE-4C41-A8B0-62B9D62409A2.png"></p>
<p>SiteInstanceGroup 在 SiteInstanceGroupManager 的 GetOrCreateGroupForNewSiteInstance 中调用（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/site_instance_group_manager.cc;l=49;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/609B214F-7144-43E5-89B7-20E0F0482526.png"></p>
<p>而 GetOrCreateGroupForNewSiteInstance 最终在 SiteInstanceImpl 的 SetProcessInternal 中调用（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/site_instance_impl.cc;l=413;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/C3920977-DF8D-4EDB-A090-88E07B8806D9.png"></p>
<p>而 SetProcessInternal 的 process 参数是 RenderProcessHostImpl 的 GetProcessHostForSiteInstance（<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/site_instance_impl.cc;l=375;drc=ceb5f7a570260bf7d588af1c7f049334681f7fdb;bpv=1;bpt=1">源码</a>）：<br><img src="/investigation-of-getting-browser-tab-performance/6160143D-CA52-4ED8-8EB1-44833E00933C.png"></p>
<p>兜兜转转，又回到了 RenderProcessHostImpl，因此数据流就通了：</p>
<ol>
<li>RenderProcessHostImpl 负责创建一个渲染子进程，通过 GenerateChildProcessUniqueId 生成一个 ID，并配置到其启动程序的 renderer-client-id 上</li>
<li>同时 FrameInstance 会绑定一个 RenderProcessHostImpl，其 ID 就是 ProcessId</li>
</ol>
<p>数据流比较稳定：renderer-client-id 从 16 年就有了，一直没变过，frame 的 processId 从 14 年就基于 RenderProcessHostImpl 的 GenerateChildProcessUniqueId 了</p>
<h3 id="Edge"><a href="#Edge" class="headerlink" title="Edge"></a>Edge</h3><p><img src="/investigation-of-getting-browser-tab-performance/4D9545FD-FFD9-4630-BD24-16D24611DD3F.png"></p>
<p>解决了 Chrome，由于 Edge 同样基于 Chromium，因此 Edge 可以直接加载 Chrome 的 Extension，另外，Edge 每个 Tab 的子进程的启动参数中也有 renderer-client-id，所以，Edge 的方案与 Chrome 基本一致：</p>
<ul>
<li>Edge 的子进程前缀是 Microsoft Edge</li>
<li>Edge 会有 PrerenderTab，在启动参数中含有  <code>--instant-process</code></li>
</ul>
<p><img src="/investigation-of-getting-browser-tab-performance/17314300416677.jpg"></p>
<p>确定了整体方案，还需要验证：</p>
<ol>
<li>能否通过代码方式，获取一个 pid 对应进程的命令行启动参数</li>
<li>Extension 如何与 Native App 进行通信</li>
</ol>
<h3 id="获取-Process-的命令行参数"><a href="#获取-Process-的命令行参数" class="headerlink" title="获取 Process 的命令行参数"></a>获取 Process 的命令行参数</h3><p>对于 Windows，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6520428/how-to-query-a-running-process-for-its-parameters-list-windows-c/6522047">How to query a running process for its parameters list? (Windows, C++)</a> 和 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/21945606/how-can-i-get-the-full-command-line-of-all-the-processes-after-doing-a-process-w">c - How can I get the full command line of all the processes after doing a process walk of the snapshot? - Stack Overflow</a>，效果如下：<br><img src="/investigation-of-getting-browser-tab-performance/28B0F088-77B3-453F-931E-EF62305585CB.png"></p>
<p>对于 Mac，参考 <a target="_blank" rel="noopener" href="https://chromium.googlesource.com/crashpad/crashpad/+/refs/heads/master/util/posix/process_info_mac.cc">Chromium 源码中的 process_info_mac.cc</a>，效果如下：<br><img src="/investigation-of-getting-browser-tab-performance/365C3BB0-BDBB-43C8-A43A-0F31B5047F5B.png"></p>
<h3 id="Extension-同-Native-App-通信"><a href="#Extension-同-Native-App-通信" class="headerlink" title="Extension 同 Native App 通信"></a>Extension 同 Native App 通信</h3><p>搜了一些文章</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://textslashplain.com/2020/09/04/web-to-app-communication-the-native-messaging-api/">Web-to-App Communication: The Native Messaging API – text&#x2F;plain</a></li>
<li><a target="_blank" rel="noopener" href="https://textslashplain.com/2019/08/28/browser-architecture-web-to-app-communication-overview/">Browser Architecture: Web-to-App Communication Overview – text&#x2F;plain</a></li>
<li><a target="_blank" rel="noopener" href="https://learning.postman.com/docs/sending-requests/capturing-request-data/interceptor/">https://learning.postman.com/docs/sending-requests/capturing-request-data/interceptor/</a></li>
</ul>
<p>主流就是两种思路：一个是通过 WebSocket，一个是基于 Chrome 提供的 Native Messaging</p>
<ul>
<li>WebSocket 的问题在于在 Extension 中是否有权限可以访问一个 WebSocket 服务器，且这个服务器是否要求必须是 wss，本地服务器的 ssl 证书不太好弄，另外安全性上风险也高一些</li>
<li>Native Messaging 看起来更合适一些，因为需求中数据传输量并不大，而且相对安全性好</li>
</ul>
<h2 id="Native-Messaging-技术调研"><a href="#Native-Messaging-技术调研" class="headerlink" title="Native Messaging 技术调研"></a>Native Messaging 技术调研</h2><p>在调试 Native Messaging 过程中发现以下问题：</p>
<ol>
<li>Host 端不能使用任何 cout 输出，否则调试不通。如果要调试，只能输出到 cerr</li>
<li>Host 端是由 Chrome 启动的，自己启动没有用，Chrome 只与自己启动的那一份进程通信</li>
<li>manifest 中 name 必须为 小写字母 . 和 _，其他均为非法</li>
<li>manifest 应该放到 <code>~/Library/Application Support/Google/Chrome/NativeMessagingHosts</code> 目录</li>
<li>manifest 的名字应该与 name 一致，为 name.json</li>
</ol>
<p>因此，Native Service 不适合作为 Extension 的 NativeMessagingHost，需要想办法，有两种方式：</p>
<ol>
<li>Extension 通过 WebSocket 连接到 NativeService</li>
<li>Extension 与 NativeService 实现一个 Proxy，用于 Extension 调用并中转消息</li>
</ol>
<p>对于 1，问题是：</p>
<ul>
<li>没有找到一个案例这样用</li>
<li>Chrome 本身对 WebSocket 的限制，例如需要使用 wss 而不是 ws</li>
<li>NativeService 配置 ssl 证书私钥感觉不安全</li>
<li>WebSocket 服务的端口号可能被占用，因此 1 不太合适</li>
</ul>
<p>对于 2，有以下方案：</p>
<ul>
<li>使用数据库：Proxy 收到数据后写入数据库，问题是通信是单向的，Ao Zhang 的经验看，在 Windows 上使用数据库不太稳，总有各种各样问题</li>
<li>使用 JSON 文件：Proxy 写入，NativeService 读取，问题是通信是单向的，且读写频率不好同步</li>
<li>使用进程间通信（Windows 是 Named Pipe，Mac 是 Unix Domain Socket）：成熟的方案，双向通信，比较稳妥</li>
</ul>
<p>基于此，架构改变为：<strong>增加一个 Extension Helper 作为 Proxy，负责接收 Extension 的数据，通过 IPC 接口转发给 Native Service</strong></p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/extensions/reference/runtime/#method-connectNative">https://developer.chrome.com/docs/extensions/reference/runtime/#method-connectNative</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/apps/nativeMessaging/">https://developer.chrome.com/docs/apps/nativeMessaging/</a></li>
<li><a target="_blank" rel="noopener" href="https://discourse.mozilla.org/t/webextension-with-native-messaging-c-app-side/30821">WebExtension with Native messaging C++ App side - Development - Mozilla Discourse</a></li>
</ul>
<h2 id="Safari-技术调研"><a href="#Safari-技术调研" class="headerlink" title="Safari 技术调研"></a>Safari 技术调研</h2><p>Safari 不是基于 Chromium，而是基于 WebKit 内核：</p>
<ol>
<li>Safari Web Extension 的 API 与 Chrome 不一样，查看其 API 文档，找到 SFSafariPage 有 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/safariservices/sfsafaripage/1639510-getpropertieswithcompletionhandl">getPropertiesWithCompletionHandler(_:)</a> 方法，可以获取 Page Property，但是 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/safariservices/sfsafaripageproperties">SFSafariPageProperties</a> 中只有 title 和 url，没有其他信息</li>
<li>Safari 虽然每个 Tab 也是对应一个进程，名称为 com.apple.WebKit.WebContent，但是并没有什么启动参数</li>
</ol>
<p>尝试搜了 Safari Web Extension 有没有什么私有 API 可以访问，在 Apple Runtime Headers 中搜了下 <a target="_blank" rel="noopener" href="https://github.com/LeoNatan/Apple-Runtime-Headers/blob/5e50ad05dfd7d7b69fc2e0e685765fc054166b3c/macOS/PrivateFrameworks/Safari.framework/BrowserTabPersistentState.h">macOS&#x2F;PrivateFrameworks&#x2F;Safari.framework&#x2F;BrowserTabPersistentState.h</a>，没有什么可以用的数据</p>
<p>Safari 可以通过  <code>defaults write com.apple.Safari IncludeInternalDebugMenu  -bool true</code> 打开 Debug 模式，在选项中将 Tab 对于的 pid 显示在 Tab 标题上。</p>
<p>后来又仔细观察了 Activity Monitor，发现 Safari 对应 Tab 的子进程，能够显示对应 Tab 的 Host URL，于是就想到了：能不能逆向 Activity Monitor，看他到底是怎么实现的。</p>
<h3 id="如何显示-Tab-的-URL"><a href="#如何显示-Tab-的-URL" class="headerlink" title="如何显示 Tab 的 URL"></a>如何显示 Tab 的 URL</h3><p>由于 Safari 使用的是 WebKit，每个 Tab 对应是 WebContents，在用 Hopper 加载 Activity Monitor 之后，开始针对 WebContents&#x2F;WebKit 进行搜索，找到了一个可疑方法，对方法进行反汇编后，定位到一个关键函数调用<code>_LSCopyApplicationInformationItem</code> 和 <code>LSActivePageUserVisibleOriginsKey</code></p>
<p><img src="/investigation-of-getting-browser-tab-performance/44F2F362-E295-40FC-8947-B5EE5E9F2C51.png"></p>
<p>用其进行 Google 搜索，找到了以下的参考代码：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/zorgiepoo/d751cba19a0167a589a2">https://gist.github.com/zorgiepoo/d751cba19a0167a589a2</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rodionovd/RDProcess">https://github.com/rodionovd/RDProcess</a></li>
</ul>
<p>在配合 <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/WebKit2/WebKit2-7607.2.6.1.1/WebProcess/cocoa/WebProcessCocoa.mm.auto.html">WebKit 源码</a>，可以看到在 WebProcess 设置名称时，会通过 <code>_LSSetApplicationInformationItem</code> 将对应名称设置为 URL。最后，自己写 Demo 验证可行性，也能像 Activity Monitor 一样显示 Tab 对应 pid 的 Host URL 了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kLSActivePageUserVisibleOriginsKey = <span class="built_in">CFSTR</span>(<span class="string">&quot;LSActivePageUserVisibleOriginsKey&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kLSDisplayName = <span class="built_in">CFSTR</span>(<span class="string">&quot;LSDisplayName&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kLSMagicConstant = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFTypeRef</span> _LSCopyApplicationInformationItem(<span class="keyword">int</span> <span class="comment">/* hopefully */</span>, <span class="built_in">CFTypeRef</span>, <span class="built_in">CFStringRef</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFTypeRef</span> _LSASNCreateWithPid(<span class="built_in">CFAllocatorRef</span>, pid_t);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *getWebKitActiveURL(pid_t pid) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *url = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CFTypeRef</span> asn = _LSASNCreateWithPid(kCFAllocatorDefault, pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (asn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">id</span> information = <span class="built_in">CFBridgingRelease</span>(_LSCopyApplicationInformationItem(kLSMagicConstant, asn, kLSActivePageUserVisibleOriginsKey));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ([information isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            url = information;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([information isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="built_in">NSArray</span> *array = (<span class="built_in">NSArray</span> *)information;</span><br><span class="line">            <span class="keyword">if</span> (array.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                url = array[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFRelease</span>(asn);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何正确的识别-Safari-的子进程"><a href="#如何正确的识别-Safari-的子进程" class="headerlink" title="如何正确的识别 Safari 的子进程"></a>如何正确的识别 Safari 的子进程</h3><p>Safari 使用的 WebKit，每个 Tab 是 com.apple.WebKit.WebContent 子进程，其  ppid 都是 1（launchd），而且如果有其他 App 使用了 WebKit（WKWebView），其子进程也是 com.apple.WebKit.WebContent，使用 ppid 的话无法和  Safari 的 Tab 区分出来。需要使用私有 API  <code>responsibility_get_pid_responsible_for_pid</code>  才能取到正确的父进程，参考：<a target="_blank" rel="noopener" href="https://apple.stackexchange.com/questions/327290/how-process-hierarchy-works-in-macos">terminal - How process hierarchy works in macOS - Ask Different</a></p>
<h3 id="如何显示-Prewarmed-Tab"><a href="#如何显示-Prewarmed-Tab" class="headerlink" title="如何显示 Prewarmed Tab"></a>如何显示 Prewarmed Tab</h3><p>Safari 有 Prewarmed Tab，此 Tab 对应的进程没有 URL，但是 Activity Monitor 能显示对应进程的名称，通过 <code>_LSCopyApplicationInformationItem(kLSMagicConstant, asn, &quot;LSDisplayName&quot;)</code>  获取进程的显示名称。</p>
<h3 id="将现有的-Chrome-Extension-转换成-Safari-Extension"><a href="#将现有的-Chrome-Extension-转换成-Safari-Extension" class="headerlink" title="将现有的 Chrome Extension 转换成 Safari Extension"></a>将现有的 Chrome Extension 转换成 Safari Extension</h3><p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/safariservices/safari_web_extensions/converting_a_web_extension_for_safari?language=objc">Converting a web extension for Safari</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun safari-web-extension-converter --app-name <span class="string">&quot;ArgusSafariHelper&quot;</span> --bundle-identifier <span class="string">&quot;com.argus.safari.helper&quot;</span> --macos-only --copy-resources  ../argus-chromium-extension/extension</span><br></pre></td></tr></table></figure>

<p> Extension 需要处理的有：</p>
<ol>
<li>删除不需要的 webNavigation 和处理权限兼容性：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Browser_compatibility_for_manifest.json">Browser compatibility for manifest.json - Mozilla | MDN</a></li>
<li>处理 <all_urls> 的兼容性：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Match_patterns">Match patterns in extension manifests - Mozilla | MDN</a></li>
<li>使用 browser 而不是 chrome 访问 Extension API</li>
</ol>
<h2 id="其他-Browser-技术调研"><a href="#其他-Browser-技术调研" class="headerlink" title="其他 Browser 技术调研"></a>其他 Browser 技术调研</h2><h3 id="Internet-Explorer"><a href="#Internet-Explorer" class="headerlink" title="Internet Explorer"></a>Internet Explorer</h3><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8445742/how-to-get-the-url-of-the-internet-explorer-tabs-with-pid-of-each-tab?rq=1">c# - How to get the URL of the Internet explorer tabs with PID of each tab? - Stack Overflow</a></p>
<h3 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h3><p>Firefox 每个 Tab 对应的子进程有启动参数，也提供了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/webNavigation">webNavigation - Mozilla | MDN</a> 的 API，但是返回的数据中并没有 processId（文档上有），不知道为啥，<a target="_blank" rel="noopener" href="https://github.com/mdn/webextensions-examples#installing-an-example">GitHub - mdn&#x2F;webextensions-examples: Example Firefox add-ons created using the WebExtensions API</a></p>
<p><img src="/investigation-of-getting-browser-tab-performance/420EB00C-9E38-4168-91B0-BE22A1456A6A.png"></p>
<p>不过 Firefox 占有率不高，所以就先不看了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/investigation-of-getting-browser-tab-performance/17314301570478.jpg"></p>
<p>实现需要 Web Extension + Native Service 配合才能实现，同时需要一个 “Proxy” 作为二者通信的中转站，因此架构主要由三块组成：</p>
<ul>
<li>Web Extension：安装在浏览器中，负责获取 Tab 的 Frame 数据和页面加载性能数据<ul>
<li>基于 Chrome Extension API，聚合多个 Event 回调，配合 content.js 中的 PerformanceObserver，生成页面加载性能数据</li>
<li>遍历 Tab 并通过 webNavigation 获取其 Frame 相关数据</li>
<li>通过 Native Messaging 与 Extension Helper 建立其连接，并接收和发送消息</li>
</ul>
</li>
<li>Extension Helper：负责消息转发<ul>
<li>通过 IPC（Windows 是 Named Pipe，Mac 是 Unix Domain Socket）与 Native Service 建立通信，Native Service 是 Server 端。</li>
<li>通过 stdin 从 Web Extension 接收消息，解码后通过 IPC 转发给 Native Service</li>
<li>通过 IPC 从 Native Service 接收消息，编码后通过 stdout 转发给 Web Extension</li>
</ul>
</li>
<li>Native Service：负责分析监控 Browser 各个子进程及其性能数据，聚合 Web Extension 数据后上传<ul>
<li>分析各个子进程的启动参数，并通过参数来区分进程类型</li>
<li>监控各个子进程的 CPU 和 Memory 性能</li>
<li>从 Web Extension 接收消息，与进程的性能数据聚合</li>
<li>将页面的 CPU 和 Memory 性能以及页面加载性能上传</li>
</ul>
</li>
</ul>
<p>最终效果如下，用界面代替“上传”：<br><img src="/investigation-of-getting-browser-tab-performance/17314313062353.jpg"></p>
<h3 id="实现过程中遇到的坑"><a href="#实现过程中遇到的坑" class="headerlink" title="实现过程中遇到的坑"></a>实现过程中遇到的坑</h3><h4 id="Chromium-Extension"><a href="#Chromium-Extension" class="headerlink" title="Chromium Extension"></a>Chromium Extension</h4><ul>
<li>postMessage 发送 JSON 数据时，要使用 <code>&#123; &quot;key&quot;: value &#125;</code> 的形式，不能 <code>var object = &#123;&#125;; object.key = value</code>，这样会导致 NativeService 端解析 JSON 数据时失败。</li>
<li>使用 Developer Mode 加载 Extension 时，每次重新加载或者换设备都会导致 Extension 的 UUID 变化，可以利用 <code>manifest.json</code> 中的 key 来锁定 Extension 的 UUID，需要申请一个 Chrome WebStore 账号，将 Extension 的 zip 包上传一次，从而获取 PublicKey。</li>
</ul>
<h4 id="Extension-Helper"><a href="#Extension-Helper" class="headerlink" title="Extension Helper"></a>Extension Helper</h4><ul>
<li>在转发数据给 NativeService 时，先发送长度，再发送 JSON 数据。有时候 NativeService 先收到 JSON 数据，导致解析出来的 length 是一个巨大无比的值，在 recv 时越界导致崩溃。后来发现如果长度和数据分两次 send 的话，就会出现这个问题，然后 1 将 NO BLOCK 模式关了，2 将长度和数据合并到一个缓冲区中用一次 send 发送，问题不再出现。</li>
<li>发送数据给 Extension 时，必须用 JSON 包一下，否则 Extension 不识别。</li>
<li>Extension Helper 由 Browser 负责启动，属于 Browser 的子进程，其生命周期和 Extension 中 <code>chrome.runtime.connectNative</code> 返回的 Port 一致，最好持有此 Port，不然每次 <code>chrome.runtime.connectNative</code> 都会创建一个 Extension Helper 子进程。</li>
</ul>
<h4 id="Native-Services"><a href="#Native-Services" class="headerlink" title="Native Services"></a>Native Services</h4><ul>
<li>Unix Domain Socket 会新建一个文件，每次在 bind 前需要用 unlink 删除，不然会导致 bind 失败。</li>
<li>允许非 root 权限程序能够读写 Unix Domain Socket，需要在 bind 前使用 umask，然后在 bind 后恢复。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mask = umask(<span class="number">777</span>);</span><br><span class="line">umask(mask);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/ios-classroom-refactor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/ios-classroom-refactor/" class="post-title-link" itemprop="url">猿辅导 iOS 直播教室重构之路 —— 教室积木化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-29 00:35:20" itemprop="dateCreated datePublished" datetime="2021-09-29T00:35:20+08:00">2021-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 02:38:58" itemprop="dateModified" datetime="2024-11-12T02:38:58+08:00">2024-11-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Architecture-iOS/" itemprop="url" rel="index"><span itemprop="name">Architecture, iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>猿辅导直播教室最早的业务形态，只有一种教室，在教室内增加各种课堂能力和活动，例如基础的课件渲染、板书笔迹等能力。在这样的业务需求下，整个教室对应一个 View Controller，教室内的每个业务模块使用 Handler（处理业务逻辑） + View（处理模块显示）的模式，教室 View Controller 是 Handler 和 View 的 Delegator，同时也接收直播引擎 SDK 的回调，调用 Handler 进行处理。</p>
<p>随着业务快速迭代，跨越 12 年不同年级和不同学科的教研要求千差万别，开始出现不同类型的新教室，当时因为各种因素为了”快“，实现新教室的方式是：拷贝教室代码后针对该类型教室进行定制。正如茨威格在《断头皇后》中写的，“她那时候还太年轻，不知道所有命运赠送的礼物，早已在暗中标注了价格”，欠下的技术债，使得直播教室的架构越来越影响开发效率和体验：</p>
<ol>
<li>教室 View Controller 越来越长，出现多个超过 5 千行以上代码的 View Controller，而且随着教室内课堂交互功能的增加，VC 的大小还会接着增长。</li>
<li>多个教室大量重复的代码，一个在多教室使用的功能，需要加多次。如果需要修改，也要改多次。</li>
<li>一个业务功能的代码不够聚合，散落在 View Controller 中多个地方，增删功能时容易遗漏，导致 Bug。</li>
<li>如果要再新增教室类型，以上问题会越来越严重。</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>经过对教室 View Controller 和业务模块进行梳理分析，发现：</p>
<p><img src="/ios-classroom-refactor/37CC0313-AEC5-419C-9054-EE019FAF06F3.png" alt="37CC0313-AEC5-419C-9054-EE019FAF06F3"></p>
<ul>
<li>业务模块 Handler 的 Delegate 都是 View Controller，由 View Controller 来更新 View 或者调度其他 Handler。</li>
<li>同时，View 的创建和层级也维护在 View Controller 中，View 事件 Delegate 给 View Controller 后交由 Handler 或者其他进行处理。</li>
<li>所有引擎 SDK 的消息也都统一回调给了 View Controller，由 View Controller 再传递给 Handler 处理。</li>
</ul>
<p>由此可以看出，View Controller 由于承载的职责过多，里面充斥了各种胶水代码，是其长度过长的主要原因，同时，由于每个业务的 View 和 Handler 都需要和 View Controller 交互，耦合导致复用性下降，新增教室时只能通过拷贝代码的形式进行。总之，现有架构最核心的问题是：<strong>View Controller 的职责太多，业务模块不够内聚</strong>，解决了这些，上面的痛点就游刃而解。</p>
<p>解决思路就是：<strong>教室积木化</strong>：</p>
<ul>
<li>构建教室像搭积木一样，每个业务模块像一块块积木，接口统一可拔插，能够灵活的根据业务要求进行组合，提高构建新教室的效率。</li>
<li>View Controller 变成承载积木的容器，以及教室内资源和状态的持有者（因为生命周期一致），代码量和职责会变得很简单，不再有冗长的胶水代码。</li>
<li>业务模块内聚，自管理与其相关的 View、Model、Event，便于集成和拔插。模块间有通信机制和分层，不再通过 View Controller 实现 Delegate 来进行调度。</li>
<li>重构过程是渐进式的，对现有的 Handler 方式改动较小。</li>
<li>能够方便业务写单元测试。</li>
</ul>
<p>为了更好的体现重构的效果，定下了一个可量化目标：</p>
<ol>
<li>教室 View Controller 代码行数<strong>降到 500 行以下</strong>。</li>
<li>业务模块在多个教室复用时，<strong>基本消除重复代码</strong>。</li>
</ol>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="业务模块-Module"><a href="#业务模块-Module" class="headerlink" title="业务模块 Module"></a>业务模块 Module</h3><p><strong>核心点：新引入 Module 的概念，将业务模块的 View 和 Handler 原本在 View Controller 中的胶水代码抽离到 Module 中</strong><br><img src="/ios-classroom-refactor/41A83409-3074-4E58-9E76-DD134E4DB76C.png" alt="41A83409-3074-4E58-9E76-DD134E4DB76C"></p>
<p>View Controller 目前会持有各个业务模块的 View 和 Handler，这些 View 和 Handler 的 Delegate 都是 View Controller，是 View Controller 中很大一部分的胶水代码，同时会在多个教室间重复，每次修改都需要在多个教室修改多遍。而引入 Module 后，Module 可以看成一个 Sub View Controller，负责持有 View 和 Handler，处理两者的 Delegate，将多个教室重复的代码整合进来，教室 View Controller 只负责创建并持有业务模块对应的 Module。</p>
<p>Module 作为教室积木化的基本单位，内聚一个业务的所有代码：</p>
<ul>
<li>管理模块自身的业务逻辑和 View。</li>
<li>监听其关心的直播命令。</li>
<li>通过接口或其他方式进行模块间通信。</li>
</ul>
<p>实现上，Module 就是一个 Protocol，定义了 Module 的生命周期方法：<br><img src="/ios-classroom-refactor/5EF6D58C-2226-4406-A400-4EBE0C341E15.png" alt="5EF6D58C-2226-4406-A400-4EBE0C341E15"></p>
<h3 id="模块间通信与依赖注入"><a href="#模块间通信与依赖注入" class="headerlink" title="模块间通信与依赖注入"></a>模块间通信与依赖注入</h3><p><strong>核心点：积木有缺口和凸起，模块也有依赖和消息，基于依赖注入 DI，两种类型均通过接口抽象，在模块初始化时根据不同教室需要，注入具体实现</strong></p>
<p>由于模块不再将消息 Delegate 给 View Controller 处理，模块与模块间需要通信，之前通信选用的方式有：直接使用通知、基于 OC Runtime 的 Mediator 方式、通过 Protocol 定义接口 + Register 注册实现的方式等，进过权衡，Protocol 定义接口这种方式更适合积木化重构的业务场景，在 Swift 语言特性的加持下，最终选用了 <a target="_blank" rel="noopener" href="https://github.com/hmlongco/Resolver">Resolver</a> 这个 Swift 版本的依赖注入 Dependency Injection 框架，实现模块间通信：</p>
<ul>
<li>每个 Module 供外部 Module 使用的接口，通过 Protocol 抽象成 Service，并通过 register 机制将 Service 注册。</li>
<li>Module 使用其他 Module 的接口时，用 @Inject 的 Property Wrapper 定义一个 Service 类型的属性，通过 Service 调用接口。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块 A 定义</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModuleA</span>: <span class="title">Service1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// doing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块 B 使用模块 A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModuleB</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> <span class="keyword">var</span> service1: <span class="type">Service1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">handleSomething</span>()</span> &#123;</span><br><span class="line">    service1.doSomething()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line"><span class="type">Resolver</span>.register &#123; <span class="type">ModuleA</span>() <span class="keyword">as</span> <span class="type">Service1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>依赖注入是一套很成熟的思想，在前后端项目上有广泛应用，积木化使用依赖注入之后：</p>
<ul>
<li>不仅仅是平级的业务 Module，只要是 Module 需要，直播教室内各项功能都可以抽象成 Service 进行注入。</li>
<li>每个 Module 依赖的是 Service 接口，而不再是具体实现，由 DI 框架 Resolver 负责将真正的 Module 绑定到 Service 中，除了解耦外，在写单元测试时能够方便进行 Mock。</li>
</ul>
<h3 id="业务模块-View-管理：Layouter"><a href="#业务模块-View-管理：Layouter" class="headerlink" title="业务模块 View 管理：Layouter"></a>业务模块 View 管理：Layouter</h3><p><strong>核心点：由于 View Controller 不再直接持有业务 View，因此 View 的层级关系、所处的区域需要从 View Controller 中抽离</strong></p>
<p>一开始的想法是由 Module 来管理，但是 Module 如果作为积木的一块，不应该对自己在教室的什么位置有假设，管理好自己 View 的状态就行，至于放到哪里应该是使用 Module 关心的。但是由 View Controller 管理的话，会导致多个教室间重复，也不够灵活。</p>
<p><img src="/ios-classroom-refactor/328C89B7-F111-4BC5-A34F-EAEFE63F2134.png" alt="328C89B7-F111-4BC5-A34F-EAEFE63F2134"></p>
<p>因此， 引入 Layouter 的概念：</p>
<ul>
<li>Layouter 管理 View Controller 的 View，按照 UI 样式划分成多个区域，并创建和排版对应区域的 View</li>
<li>Module 将 View 注册到 Layouter 中，Layouter 负责将 View 按照 Identity 和 Priority 安置在期望的区域，并安排好层级关系</li>
</ul>
<p>实现上 Layouter 和 Module 一样，都是一个 Protocol，不同类型的教室布局实现各自具体的 Layouter，在 layout 方法中进行布局。<br><img src="/ios-classroom-refactor/6C0CA314-26EB-48C0-8D3C-DDB5E12FBA39.png" alt="6C0CA314-26EB-48C0-8D3C-DDB5E12FBA39"></p>
<p>另外，有些区域内的排版在多个 Layouter 中是一样的，在 Layouter 的基础上引入 Area Layouter 的概念，负责一块区域的排版布局，例如课件区，Room Layouter 通过持有 Area Layouter 实现区域布局的复用。</p>
<p><img src="/ios-classroom-refactor/4679D1F3-E016-4D3A-9D6E-DF7E7F5E1BE3.png" alt="4679D1F3-E016-4D3A-9D6E-DF7E7F5E1BE3"></p>
<h3 id="教室状态持有者：Store"><a href="#教室状态持有者：Store" class="headerlink" title="教室状态持有者：Store"></a>教室状态持有者：Store</h3><p><strong>核心点：业务模块不再通过 Delegate 拿教室内的通用数据，而是通过 Store 将通用数据传入</strong></p>
<p>各个业务模块经常通过 Delegate 从 View Controller 中获取例如 episodeId、teamId、userId、Episode 之类的数据，而这些数据可以理解是教室内的基础数据或状态，可以将这些数据整合到一个叫 Store 的模块中，通过依赖注入到 Module 中，这样就没必要再通过 Delegate 从 View Controller 中拿数据，省去一些胶水代码。</p>
<p><img src="/ios-classroom-refactor/5C2F2D49-2AFF-40D5-9B79-BACCAA995E91.png" alt="5C2F2D49-2AFF-40D5-9B79-BACCAA995E91"></p>
<p>Store 也使用 Protocol 定义，不同类型教室实现具体的 Store，当一个 Module 在多个教室复用时，虽然 Store 可能实现不一样，但 Store Service 的接口是一致的，使得 Module 在多教室复用变得容易。</p>
<h3 id="直播命令调度拆分：Dispatcher"><a href="#直播命令调度拆分：Dispatcher" class="headerlink" title="直播命令调度拆分：Dispatcher"></a>直播命令调度拆分：Dispatcher</h3><p><strong>核心点：由业务模块主动注册其关心的直播命令，不再通过 View Controller 调度</strong></p>
<p>直播命令的回调不再通过 View Controller 调用，直接发送到业务模块上，一方面能从 View Controller 删除很多胶水代码，另一方面能明确一个模块关心的直播命令。</p>
<p><img src="/ios-classroom-refactor/DF78592C-7BCD-49AC-930A-206CF5A5E01A.png" alt="DF78592C-7BCD-49AC-930A-206CF5A5E01A"></p>
<p>实现一个直播命令注册与转发的模块：Dispatcher</p>
<ul>
<li>通过依赖注入到 Module 中，Module 使用 Dispatcher 显式声明自己需要的直播命令。</li>
<li>参考 RxSwift 的思想，通过注册 Block 的方式实现通知，相比 Notification 通知，这样引擎消息参数处理起来更安全和方便。</li>
<li>Dispatcher 支持优先级，根据业务场景提供分发前、分发中、分发后三种队列。</li>
<li>对于复合命令，由 Dispatcher 进行拆分后分发给业务 Module，业务 Module 不需要再关心复合命令细节，对其无感知。</li>
</ul>
<h3 id="教室容器化"><a href="#教室容器化" class="headerlink" title="教室容器化"></a>教室容器化</h3><p>在上面的设计中，Module、Layouter、Store 都是 Protocol，为什么要用 Protocol 呢？这种面向接口编程带来的灵活性是为了能够将教室 View Controller 变成一个容器，不再关心里面到底有哪些模块，如何排版布局等，所有类型教室共用该容器 View Controller：<br><img src="/ios-classroom-refactor/6C13C0A4-E3B3-4371-8376-615882190670.png" alt="6C13C0A4-E3B3-4371-8376-615882190670"></p>
<p>至于该往教室容器中传入具体哪些 Module，使用哪种 Layouter 和 Store，这些策略交由 RoomFactory 生成。Factory 也是一个 Protocol，不同策略实现不同具体的 Factory，符合 OCP 原则。<br><img src="/ios-classroom-refactor/E46A2299-F2AD-4081-8319-67488C20A080.png" alt="E46A2299-F2AD-4081-8319-67488C20A080"></p>
<p>基于容器化教室和策略工厂的设计，业务上能够根据配置决定加载哪些 Module，从而进行功能灰度和回退，或者针对一个 Service，有 A、B 两个实现 Module，根据配置进行加载，进行 A&#x2F;B Test，极大的提升了灵活性。</p>
<h2 id="推进过程"><a href="#推进过程" class="headerlink" title="推进过程"></a>推进过程</h2><p>完成了重构的方案设计后，如何推进重构方案的落地是一件比方案设计更有挑战性的事情，需要脚踏实地的一点点啃掉：</p>
<ul>
<li>直播教室作为猿辅导的核心业务场景，一旦出问题直接影响用户核心体验，其稳定性要求高，如何保证重构方案能够比较平稳的落地？</li>
<li>业务还在不断迭代，开发人力一直比较紧张，如何协调资源？重构任务应该如何安排，才能即不影响需求迭代速度，又能及时完成，不在同步业务最新改动时耗费大量精力？</li>
</ul>
<h3 id="做好重构规划"><a href="#做好重构规划" class="headerlink" title="做好重构规划"></a>做好重构规划</h3><p>首先，直播教室既有老师端又有学生端，确定先重构老师端再重构学生端的方向：</p>
<ul>
<li>老师端是内部分发，用户也是内部老师，灰度范围、发 Fix 等更可控，风险要低一些。</li>
<li>老师端是纯 Swift 实现，也不需要考虑回放场景和回放教室，重构方案更容易落地。</li>
</ul>
<p>之后，就要规划出关键路径，寻找并行点，让能够并行的任务尽量并行：</p>
<ul>
<li>在完成重构方案设计后，开始实现基础定义，例如 Module、Layouter、Store 等定义，这些是关键路径，不完成的话会 Block 之后的工作。</li>
<li>基于上一步的基础数据结构，对一个业务模块进行积木化改造，验证重构方案的可用性，并积累积木化改造的方案。</li>
<li>完成一个模块之后，开始进人：Dispatcher 相对比较独立，可以交给一个同学负责；另外一个同学一起来对教室内相对基础和通用的模块进行积木化改造，为业务模块的改造提供前提。</li>
<li>当 Dispatcher、Layouter 和基础模块完成改造后，就开始对一个教室进行重构，好处是：<ul>
<li>一个教室完成改造后就能自测和初步提测，验证积木化整体流程的稳定性，提前暴露底层实现的重大问题。</li>
<li>教室间 70% - 80% 的业务模块是复用的，改造完一个教室，其他教室的工作量就小很多。</li>
<li>改造完的教室可以做为模板，方便其他教室进行改造时进行参考。</li>
</ul>
</li>
<li>当完成了一个教室改造后，分工如下：<ul>
<li>一个同学负责自测后提测，并修复该教室一些严重问题。</li>
<li>另一个负责实现模块的内存泄露检测工具，用于发现内存泄露问题。并编写积木化改造 101 文档，介绍对业务模块进行改造的方式和技巧。</li>
</ul>
</li>
<li>基于积木化改造 101 文档和已经改造完成的教室，进更多的人，每个人负责一个教室，这样能在短时间完成所有教室的改造。</li>
</ul>
<h3 id="把握住关键时间节点"><a href="#把握住关键时间节点" class="headerlink" title="把握住关键时间节点"></a>把握住关键时间节点</h3><p>重构什么时候开始搞，需要把握住关键时间节点才能降低成本，使得收益最大化。判断什么时候最合适，需要通过不断深入到业务中，分析规律，多和 PM、运营聊天，了解他们下一步的规划，在线教育的业务特点和上课时间比较有规律性，把握规律后，在很少会有新教室类型的时间段内，努力抓住时间节点推进重构的进行。</p>
<h3 id="重复并不是所有情况下都是坏的"><a href="#重复并不是所有情况下都是坏的" class="headerlink" title="重复并不是所有情况下都是坏的"></a>重复并不是所有情况下都是坏的</h3><p>为了保证重构完成后线上的稳定性，需要先进行小规模灰度，监控被灰度用户的各项指标，在出问题时能够及时回退到重构之前的版本。如何保证回退没有问题？那就是旧教室旧逻辑完全保留，如果涉及到修改，就拷贝一份再修改，通过重复来确定重构前的环境没有变化，这样保证回退时能够回退到“和以前一模一样”，当积木化重构在线上平稳后，再将旧代码一起全部删除。</p>
<p>我们看一下积木化重构后的成果，看是否满足最开始定下的可量化目标：</p>
<ul>
<li>将多个 5000 行左右的 VC 合并为一个只有不到 300 行的容器 VC。</li>
<li>消除一个业务功能在多个教室间的重复。</li>
<li>新增教室复合 OCP 原则，不修改教室容器 VC，而是扩展 Factory。</li>
<li>一个教室增删模块只需要改一行代码。</li>
</ul>
<h2 id="Beyond-技术"><a href="#Beyond-技术" class="headerlink" title="Beyond 技术"></a>Beyond 技术</h2><p>积木化整个重构过程，在技术之外还有很多感悟和收获，这里也想聊一聊：</p>
<h3 id="关注人的因素"><a href="#关注人的因素" class="headerlink" title="关注人的因素"></a>关注人的因素</h3><p>教室积木化是涉及到老师端、学生端核心业务场景的大重构，需要协调很多资源团队合作才能完成，那我们需要更关注人的因素，让参与进来的所有人都意识到重构不是炫技，不是开发瞎搞，而是件对大家都好的事情：</p>
<ul>
<li>对于开发同学，积木化重构解决的是大家的长期以来的痛点，“天下苦秦久矣”，用重构的设计方案和大家多描述重构之后的样子，大家就有动力参与进来。同时，重构过程中有很多活都是脏活累活，一个人做的话很容易疲劳和烦躁，一点经验是多几个人，大家分一分，一个人头上没几个，也能感觉到团队作战的优势。</li>
<li>对于 PM 同学，在进行积木化重构方案设计时就不断同他们沟通，了解之后的长期迭代方向，并同步重构的作用是为了更好的支撑产品迭代，例如能够提供更灵活的配置与 A&#x2F;B Test，例如能更快的增删模块，“给我一首歌的时间”就完成了。这样 PM 同学在需求排期上也愿意为重构协调时间。</li>
<li>对于测试同学，虽然重构需要教室全功能回测，工作量较大，但是同样的，重构之后，由于少了很多重复代码，不容易遗漏，交付质量也会有所提升，增删模块的提测时间会更早，同时，在提测过程中，也及时同步了为什么先提测一个教室，再整体提测，测试同学也能更认可。</li>
<li>对于上级 Leader，依次从能够更好支撑业务，提高代码质量，让开发同学写代码更开心等几个方面说明重构的意义，同时也提供了详细的设计文档和 Roadmap，于是 Leader 也认可这件事情，帮忙协调资源等。</li>
</ul>
<p>总之，上面所有看起来像“影响力”的东西，都基于平时日积月累的“信任感”，做好每一个需求，认真对待交付质量和 Bug，多和 PM 沟通交流，与其他团队建立良好的关系，成为一个“靠谱”的工程师，这些东西终归在积木化重构上得到回报。</p>
<h3 id="但行好事，莫问前程"><a href="#但行好事，莫问前程" class="headerlink" title="但行好事，莫问前程"></a>但行好事，莫问前程</h3><p>直播教室由于业务方向上的不断快速迭代和探索，积累了大量技术债，导致无法通过简单重构解决，同时直播教室又是核心业务场景，对其进行大重构，风险不低，说心里话，是会害怕的，怕重构出故障，怕投入大量资源却没有完成。这时候需要的就是<strong>勇气</strong>，既然这件事经过判断是对的事情，能够为业务带来价值，同时也做好了设计和规划，就应该抛开其他想法，有勇气去把事情搞定。</p>
<p>有勇气开始后，设计出来重构方案时是激动的，但没有落地的方案都是“纸上谈兵”，而重构的落地过程是枯燥的，有很多脏活累活，有很多设计时没有想到的问题，没有捷径，只能“结硬寨，打呆仗”一点点解决，中间有想放弃的时刻，有很烦躁的时候，还是咬牙坚持了下来。</p>
<p>我是幸运的：iOS 团队的小伙伴们都很给力，大家一起努力把事情搞定。PM 和测试同学也非常支持，愿意协调排期。我的 Leader 全力支持，在业务压力较大的时候，协调了 Android 同学来写一些 iOS 需求，为积木化重构空出了 iOS 人力，也非常感谢 Android 同学的支援。</p>
<p>最终，有了勇气，有了坚持，再加上幸运，经过 2020Q4、2021Q1 两个 Q 的努力分别完成了老师端和学生端的教室积木化重构，所有的辛苦和投入在 2021Q2 得到了回报，这个 Q 上了 4 个新教室，证明之前判断的正确性，给自己带来极大的成就感和正反馈，难以想象如果没有经过积木化重构新增 4 个新教室的样子。</p>
<p>总之，但行好事，莫问前程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/ios-classroom-mock-hollywood/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/ios-classroom-mock-hollywood/" class="post-title-link" itemprop="url">猿辅导直播教室 Mock 工具 —— Hollywood</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-12 22:12:52" itemprop="dateCreated datePublished" datetime="2021-08-12T22:12:52+08:00">2021-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 02:48:14" itemprop="dateModified" datetime="2024-11-12T02:48:14+08:00">2024-11-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于客户端的 Mock 工具，你可能第一时间想到是 Charles，为什么不用 Charles 进行 Mock 呢？因为对于直播场景的编程模式，与其他通过 HTTP 请求拉取数据并渲染的模式不太一样，有如下特点：</p>
<ul>
<li>服务器推送：在直播场景中，一般是由服务器将数据主动推送到客户端，而不是常见的由客户端发送 HTTP 请求拉取数据后渲染。推送数据的通道一般是基于 TCP 的长链接通道（也可能是 UDP），封装成 SDK 向使用方回调数据。</li>
<li>二进制数据格式：数据格式上一般为了传输性能和效率，也不是人类可读的 JSON 格式，而是机器友好的 ProtocolBuffer 或者 FlatBuffer。</li>
<li>数据获取方式并不唯一：有时为了性能，通过数据通道推送的只是一个 Trigger 命令，客户端在收到此命令后，再通过 HTTP 请求拉取数据。或者提交数据时使用的 HTTP 请求，后续的数据更新基于数据通道推送。</li>
<li>活动中会存在多个角色的交互：例如，一个活动需要在一端操作开始，另一端才能参与，参与过程中还需要不断同步状态。</li>
<li>有些活动是一次性的：一旦结束无法重新开始，需要重新配置直播间。</li>
</ul>
<p>对于直播客户端的特点，在进行业务开发时会有以下痛点：</p>
<ol>
<li>无论是服务器主动推送的方式、还是构造 ProtocolBuffer 这种格式的数据，都很难进行 Mock，有时还要配合着 HTTP 请求一起 Mock。</li>
<li>有时会依赖服务端或另外一个客户端开发完成，才能进行联调，当环境不稳定或者进度不同步时，会被 Block，联调出现问题时也不好排查。</li>
<li>直播对性能要求较高，压测需要服务端配合，灵活性和配置性不好保证。</li>
</ol>
<p>因此，直播客户端需要一个 Mock 工具，能够对基于 TCP 长链接的 Protobuf 格式直播命令和基于 HTTP 请求的 JSON 格式 API 数据都进行 Mock，从而能够提高直播客户端同学的开发与联调效率。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>在设计 Mock 系统时，涉及的问题点有：</p>
<ul>
<li>如何推送 Mock 的直播命令？</li>
<li>如何拦截 HTTP 请求？</li>
<li>如何使 Mock 尽量不对业务代码造成干扰？</li>
<li>触发 Mock 数据的交互方式是什么？</li>
<li>Mock 数据如何构造？有没有简便方式？</li>
</ul>
<p>在思考这些问题点如何解决时，会发现将 Mock 逻辑放到客户端还是服务端，直接决定了问题解决方式的不同，因此有以下方案进行选择：</p>
<h3 id="方案一：纯服务端逻辑"><a href="#方案一：纯服务端逻辑" class="headerlink" title="方案一：纯服务端逻辑"></a>方案一：纯服务端逻辑</h3><p>对于 TCP 和 HTTP 均实现一个中间层代理，代理中有一个白名单，对于匹配到白名单的项，返回 Mock 数据，对于不匹配的项，去源服务器拿数据。<br>优点是：对客户端透明，几乎不需要改动，需要一个开关配置是否走代理<br>缺点是：</p>
<ul>
<li>TCP 代理比较麻烦，白名单也需要配置</li>
<li>针对某个开发的独立配置不是很好搞，多个同学一起使用时可能会互相冲突</li>
<li>需要服务器同学参与和维护，而 Mock 工具本身主要给客户端用，谁痛谁更有动力去解决</li>
</ul>
<h3 id="方案二：纯客户端逻辑"><a href="#方案二：纯客户端逻辑" class="headerlink" title="方案二：纯客户端逻辑"></a>方案二：纯客户端逻辑</h3><p>直播命令的 Mock 分发和 HTTP 拦截均在客户端本地做，交互也在客户端做，这样的好处是不依赖服务器端，简单一些，也相对可控。但是缺点主要是每个客户端需要实现一遍，而且对于移动端而言，界面较小，增加交互不方便，每次改数据可能都需要改代码，也比较麻烦。</p>
<h3 id="方案三：客户端拦截-本地服务"><a href="#方案三：客户端拦截-本地服务" class="headerlink" title="方案三：客户端拦截 + 本地服务"></a>方案三：客户端拦截 + 本地服务</h3><p><img src="/ios-classroom-mock-hollywood/F4602B1E-9BC7-48EB-AB1A-D784CB4F6CA4.png"><br>针对方案二的问题，方案三进行优化，客户端只做分发 TCP 命令和 HTTP 拦截的功能，其他功能放到一个本地 Server 上：</p>
<ul>
<li>客户端实现 Hook 直播命令分发入口，允许 Mock 数据进行分发。</li>
<li>客户端实现全局 HTTP 请求的拦截器，可以拦截特定 API 返回预置的 JSON 数据。</li>
<li>客户端实现一个独立模块，用 WebSocket 连接本地 Server，本地 Server 负责下发 Mock 命令和 HTTP 拦截的数据。</li>
<li>由本地 Server 实现交互界面，独立实现，可以在多端共用，同时由于是本地 Server，可以自己根据需求定制 Mock 策略，不会影响别的同学。</li>
</ul>
<p>最终我们选用方案三作为最终方案，虽然每个客户端平台 iOS、Android、Electron 都要实现一遍 Client 端，但 Client 端的定位是尽量薄，只进行直播命令的分发和 HTTP 的拦截转发，将通用和复杂的逻辑与交互放到 Server 端，可以多端复用，不需要实现多遍。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p> 在确定了 C&#x2F;S 架构方案后，基于 WebSocket 的通信通道，需要定义 Client 与 Server 之间的通信协议：协议类型使用 JSON，可读，方便扩展</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  “type”: “”</span><br><span class="line">  “payload”: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协议中，主要有两个字段：</p>
<ul>
<li>type：用于描述通信消息类型，例如控制消息、直播命令、HTTP 拦截配置等。</li>
<li>payload：该类型消息的数据载体，不同类型的消息使用不同类型的结构，对于 Protobuf 这类二进制类型的数据，使用 Base64 进行编码，收到后再进行解码。</li>
</ul>
<p>在消息通信中，除了 Client 与 Server 之间的控制消息外，主要是 Server 往 Client 推送的 Mock 数据，这些 Mock 数据有不同类型的直播命令，有 HTTP 拦截配置与数据，应该如何组织这些数据呢？为了更方便的管理与扩展 Mock 数据，引入几个基础的数据定义：</p>
<p>首先引入了 Action 的概念，在直播的 Mock 场景下，一般是由 Server 端推送数据给 Client 端，无论是 Mock 的直播命令，还是对 URL 的拦截设置与 Mock 数据，不关心数据到底是什么类型，均抽象为 Action，代表 Server 端告诉 Client 端要做的“动作”。</p>
<p>其次是 Scene，在 Action 的基础上，多个 Action 集合在一起成为 Scene（场景），因为在开发或自测过程中，有时经常需要多种数据集合，Scene 就是一种场景下所有 Mock Data 的配置，我们一般使用的就是 Scene。</p>
<p>Scene 我们使用 JSON 格式，因为 JSON 可读性强，使用方便，每个 Action 是一个 JSON 字典，而 Scene 就是一个包含多个 JSON 字典的 JSON 数组。</p>
<p>明确了数据协议，我们就分别看一下 Client 端和 Server 端的设计。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p><img src="/ios-classroom-mock-hollywood/B13422CB-71C9-4A6D-B669-83343D97BD5E.png"><br>对于 Client 端的设计，简单分为三层，如图所示：</p>
<ul>
<li>基础层：提供一些例如协议解析的基础能力</li>
<li>功能层：每个模块负责一项独立功能</li>
<li>业务层：通过调度功能层模块，描述业务逻辑</li>
</ul>
<p>其中</p>
<ul>
<li>Message Translator：负责解析 Client 端与 Server 端定义好的协议</li>
<li>Channel Connector：负责连接 Server 的 WebSocket 服务，解析协议，向上层提供回调。</li>
<li>Request Interceptor：负责接收配置，拦截 API 请求，将匹配的请求转给 Server 端处理。<ul>
<li>对于 iOS，使用 NSURLProtocol 进行全局的 API 拦截，对于正则匹配到的 URL，将其 Host 修改成 Mock Server 的地址。</li>
<li>对于 Android，基于 OKHTTP Client 的 Interceptor，可以将匹配的 URL 进行转发。</li>
</ul>
</li>
<li>Command Trigger：负责将直播命令分发出去。这里需要注意，作为一个 Mock 工具，我们应该尽量降低对业务代码的侵入性，因此<ul>
<li>对于 iOS，基于 Objective-C 的动态性特点，只需要拿到一个 id 类型的 target，使用 NSInvocation 就可以在没有 target 对应头文件的情况下，向该 target 发送消息。</li>
<li>对于 Android，基于 Java 的反射机制，传入 Any 类型的一个 Object，在不显式依赖业务对象的情况下，通过反射对其进行调用。</li>
</ul>
</li>
<li>Manager：负责 Client 端的上层策略，调度子模块。</li>
</ul>
<ol>
<li>调用 Channel Connector 连接 Server</li>
<li>将收到的 Mock Command 通过 Command Trigger 分发出去</li>
<li>将收到的 API Mock Config 通过 Request Interceptor 进行设置</li>
</ol>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p><img src="/ios-classroom-mock-hollywood/BAD3604A-9152-4094-B5AC-79BF785D2EB7.png"></p>
<p>相对于 Client 端，Server 端的设计就更复杂一些，但核心依然是三层，多了一个 UI 显示层，用于负责用户交互。</p>
<p>对于基础层：</p>
<ul>
<li>和 Client 端一样，Server 端也有一个 Message Translator 来负责解析通信协议。</li>
<li>Logger：负责记录 Communicator 和 HTTP Server 运行过程中的日志。主要目的是有一个记录，可以查看 Mock 数据流的正确性。</li>
<li>Encoder：负责将 Action 中 JSON 格式的直播命令编码为 Protocol Buffer 格式。</li>
</ul>
<p>而功能层：</p>
<ul>
<li>Communicator ：负责提供 WebSocket 服务，接收新连接，解析协议，将数据按照协议格式发送至各个连接端，或接受连接端的消息，解析后将消息交给上层消费。</li>
<li>HTTP Server：负责提供 HTTP Server 服务，接收 Mock 的 API 请求，返回特定的数据或者错误码。</li>
<li>Scene Loader：负责从本地加载 Scene 文件，以及将运行时创建 Scene 保存到本地。</li>
</ul>
<p>再看下业务层：</p>
<ul>
<li>Client Manager：负责管理 WebSocket 连接上的 Client，展示 Client 信息、断开连接、是否接受命令等。</li>
<li>Scene Manager：负责 Scene 的管理，包括创建新的 Scene、调用 Scene Loader 加载已有的 Scene，以及对 Scene 中的 Action 进行增加、删除、修改、移动位置等</li>
</ul>
<p>最后，我们着重看一下 Mock 逻辑的“发动机” —— Player。再次回想下直播的特点，是由服务端主动推送数据和状态到客户端，在进行 Mock 时也遵循此特点，由 Action 描述要客户端做的事情，一个 Action 序列形成 Scene。那如何才能灵活高效的处理 Scene 呢？我们将处理 Scene 的过程抽象为“播放”：</p>
<p><img src="/ios-classroom-mock-hollywood/hWOQsRGgHvFIUSH4.png!thumbnail.png"></p>
<ul>
<li>Scene 是一个 Action 序列，每个 Action 都有 index，“播放”到该 Action 其实就是将该 Action 通过 Communicator 发送出去</li>
<li>既然是播放，默认使用 next 播放下一个的策略，同时也支持随意更换当前播放 index 的能力</li>
</ul>
<p><img src="/ios-classroom-mock-hollywood/xHnD6EOpvGaz4ntr.png!thumbnail.png"></p>
<ul>
<li>通过增加一个 Timer，能够实现自动播放下一个的（即自动播放）的效果</li>
</ul>
<p><img src="/ios-classroom-mock-hollywood/YRwP1Wt6OefGQyiY.png!thumbnail.png"></p>
<ul>
<li>最后，当播放到 Action 序列末尾时，支持重置为 0，实现循环播放效果，配合上自动播放，可以实现自动重复循环播放的能力，而这项能力是客户端压力测试的关键。</li>
</ul>
<p>下面我们看一个真实的案例，假如我们直播有一个投票功能，需要在一端触发，然后直播间所有其他用户均可以看到投票选项，并进行投票，投票后能看到不同选项的比例。</p>
<ul>
<li>开始投票和结束投票均通过直播命令 StartVote&#x2F;EndVote 触发</li>
<li>提交投票则是通过 HTTP POST 请求 room&#x2F;{roomId}&#x2F;vote 提交</li>
<li>投票后的选项比例也是通过直播命令 VoteStatistic 来更新</li>
</ul>
<p>在 Mock 出现前，直播客户端需要：</p>
<ol>
<li>依赖服务器端、触发端都完成开发，达到联调状态才能开始联调</li>
<li>测试各种 Corner Case 状态比较困难，例如在 POST 请求过程中收到了 EndVote，例如 EndVote 之后再次 StartVote，收到了上一次的 VoteStatistic 等</li>
</ol>
<p>有了 Mock 工具，只需要根据定义的协议，构造好 Scene 脚本，不依赖服务端和触发端即可进行联调和测试：</p>
<p><img src="/ios-classroom-mock-hollywood/YfY8OnEQDZvKKGRV.png!thumbnail.png"></p>
<ol>
<li>构造 Scene 脚本：<ul>
<li>首先建一个 URL 拦截配置，将匹配 room&#x2F;{roomId}&#x2F;vote 的 URL 转发到 Mock Server，并设置 delay 多久返回和返回码是多少</li>
<li>构造 StartVote 命令，配置上 voteId 和选项个数，</li>
<li>构造 VoteStatistic 命令，配置 voteId 和对应选项的数值</li>
<li>构造 EndVote 命令，配置 voteId</li>
</ul>
</li>
<li>完成 Scene 的构造后，通过 Player 加载该 Scene，然后执行 next 即可进行主流程的测试，同时，可以对 Scene 进行任意调整，用于测试上面说到的各种 Corner Case</li>
</ol>
<h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>在 Mock 工具出现之前，当客户端一些场景（例如讨论区）需要压力测试时，一般都需要服务器端同学配合，由他们构造数据进行推送，内容、量级、时长都不是很好定制，也不能随时随地根据需求很快的构造出来压测环境。而现在基于 Mock 工具，我们只需要构造几条不同类型的消息，将播放策略调整为自动重复循环播放，设置好自动播放的 interval 间隔，就可以很方便的进行压力测试，且压力测试的参数可以自由定制。</p>
<p>在压力测试过程中，由于是重复播放，有些字段不适合使用 Scene 中固定的值，因此，在 Action 格式中，引入了“变量”的概念，用一个特殊的标识符+文本，标识出一个“变量”，在 Action “播放”时实时替换该“变量”值，例如：</p>
<ul>
<li><code>#timestamp#</code>：会替换为执行时的时间戳</li>
<li><code>#random#</code>：会替换为一个随机值</li>
<li><code>#increase[\w]-[初始值]-[步长]#</code>：自增器，会根据初始值 + 步长进行自增</li>
</ul>
<p>以上就是直播教室 Mock 工具设计的全部内容了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/how-to-keep-foresight-in-none-infra-team/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/how-to-keep-foresight-in-none-infra-team/" class="post-title-link" itemprop="url">如何在业务团队保持”技术前瞻性“？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 01:00:51" itemprop="dateCreated datePublished" datetime="2021-03-29T01:00:51+08:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-10 21:41:57" itemprop="dateModified" datetime="2024-11-10T21:41:57+08:00">2024-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thought/" itemprop="url" rel="index"><span itemprop="name">Thought</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作为技术人员，一直很羡慕别人在基础设施领域做的一些很牛逼的工具和框架，虽然业务看起来就是在”搬砖“，但业务以及业务背后的服务才是一个公司的根本，这也是为什么有些公司技术并不牛逼，但发展却超出想象的原因。这并不代表对技术不重视，反而相反，将技术与业务结合起来，能够用合适的技术将业务支撑起来也是工程师的核心价值，毕竟工程师，就是“能将梦想照进现实的人”。</p>
<p>那作为一个业务团队，如何能够保持”技术前瞻性“，支撑业务的快速发展和迭代？所谓”前瞻性“，就是”晴天修屋顶“，听起来很好理解，但实际涉及到的问题有：</p>
<ul>
<li>如何判断什么时候是晴天，即什么时候需要修？</li>
<li>应该修什么样的屋顶？</li>
<li>用什么工具和办法修？</li>
</ul>
<p>我就从下面几个方面，谈谈我的思考</p>
<h2 id="真正深入业务，了解业务全貌，跟进业务走向"><a href="#真正深入业务，了解业务全貌，跟进业务走向" class="headerlink" title="真正深入业务，了解业务全貌，跟进业务走向"></a>真正深入业务，了解业务全貌，跟进业务走向</h2><p>在业务开发团队，开发同学经常有的迷茫和吐槽是：</p>
<ul>
<li>感觉就是在搬砖，PM 给个需求就做，天天就在写需求，没意思，也没什么技术成长</li>
<li>这个需求感觉好傻啊，为什么要这样搞？这个需求又大又急，为什么这么急？代码越搞越脏</li>
</ul>
<p>当然，不排除有运营或者 PM 提一些“拍脑袋”的需求，但这是业务开发团队相对难以改变的，要么换家公司（我感觉这方面都差不多吧？），要么拍回去，剩下能做的，就是从开发团队本身看看能做什么？</p>
<p>在业务开发团队，我认为非常重要的一点就是”真正深入业务“，对于开发同学，可能容易只看到技术，忽略业务本身。但在业务开发团队，技术是支撑业务的，只有深入了解业务，才能在业务角度做出”前瞻性“。</p>
<h3 id="了解公司业务全貌"><a href="#了解公司业务全貌" class="headerlink" title="了解公司业务全貌"></a>了解公司业务全貌</h3><p>《Netflix 文化手册》中的文化准则 2 是”要培养基层员工的高层视角“。我以前也觉得自己就是”搬砖”的，战略、业务啥的都是大佬考虑，自己做好活就行了，后来发现不对：</p>
<ul>
<li>公司需要的是聚焦，人多不一定力量大，人的力气往一处使才力量大，这也是 OKR 做聚焦的目的。当了解公司业务全貌后，能比较清楚知道自己做的工作是否和公司方向对齐，聚焦自己的工作。</li>
<li>团队变多后团队之间的交互反而容易出问题，因为没有人能总览全貌，当流程较长且对流程不熟悉时，整个项目容易出问题。而熟悉业务全貌后，能够发现团队间交互问题，提前暴露风险。</li>
</ul>
<h3 id="做需求时多问问背景"><a href="#做需求时多问问背景" class="headerlink" title="做需求时多问问背景"></a>做需求时多问问背景</h3><p>我觉得很多时候开发人员需求做得恶心，并不是因为难或者有技术挑战，反而是因为觉得没有意义或者不知道有什么意义，那这个时候需求背景就显得很重要了。</p>
<ul>
<li>在看 PRD 时，我们经常忽略掉背景的 WHY，而只关注要做什么的 WHAT。当我们了解了公司业务，明白了需求背景，才能意识到这个需求有意义，做起来相对有动力一些，也更能从长期思维考虑，在实现时如何更全面。</li>
</ul>
<h3 id="跟进业务走向"><a href="#跟进业务走向" class="headerlink" title="跟进业务走向"></a>跟进业务走向</h3><p>有时候不明白为什么 PM 突然出了一个又急又大的活，这就需要我们多关注产品&#x2F;UI OKR，多和 PM 聊聊天，提前探探他们之后想做哪方面的尝试，这样能够在技术上提前准备好。</p>
<ul>
<li>例如要更活泼的交互，那就多调研动画框架等</li>
<li>例如要开更多的教室或课堂活动，那就做架构重构，提高配置灵活性等</li>
<li>例如要提高运营或者生产效率，那就分析流程，将流程平台化等</li>
</ul>
<h2 id="关注人员-组织变化，提高对接效率"><a href="#关注人员-组织变化，提高对接效率" class="headerlink" title="关注人员&#x2F;组织变化，提高对接效率"></a>关注人员&#x2F;组织变化，提高对接效率</h2><p>在业务团队，除了关注业务上的演进方向外，还有一方面特别容易被忽略，就是：人员（组织）变化。</p>
<p>随着业务需求，公司或者团队可能会快速扩充某个团队或者组建新的团队，当团队人数急剧增加或者需要和新团队频繁对接时（很多情况不是技术团队扩张，而是非技术团队扩张），原来一些手动操作的工作就成为的效率瓶颈，也会让业务团队的开发感到”烦躁“，觉得自己每天都在做一些琐碎工作；同时团队间如果依赖过重，导致互相影响，在联调和问题排查时也非常难受。</p>
<p>那业务团队可以做的“前瞻性”工作就是提高效率。具体措施是：</p>
<ul>
<li>将手动操作自动化：将之前手动跑的 SQL 或者操作脚本化，配置成 Job，自动定期跑 + 将结果推送给关心的人；将手动检查做成对非技术同学更友好的形式，搞成自动检查任务，每次自动检查。</li>
<li>将配置&#x2F;管理平台化：以前人少的时候还可以自己手动改改配置，手动发布之类，随着人数增加，需要实现一个配置&#x2F;管理的平台，交给使用方根据自己需求进行配置和管理，业务团队的开发同学就可以从琐碎配置中解放出来，主力维护平台。</li>
<li>隔离变化：当团队变多，需求的开发链条变长后，作为开发联调中的一环，需要隔离其他团队由于内部变化而导致的问题。</li>
</ul>
<p>以上做法，除了提高效率外，还能应对团队规模变化，例如平台化了之后，由于对接的是平台，人数可以随意扩容，算法复杂度从  O(n) 降为 O(1)。</p>
<h2 id="深入和扩充技术栈，真正用技术支撑业务"><a href="#深入和扩充技术栈，真正用技术支撑业务" class="headerlink" title="深入和扩充技术栈，真正用技术支撑业务"></a>深入和扩充技术栈，真正用技术支撑业务</h2><p>技术同学容易犯两种错误：</p>
<ul>
<li>新技术是”银弹“：拿着锤子看啥都是钉子，为了上新技术而上新技术，或者为了造轮子而造轮子，而不考虑业务的落地场景，是否真正解决痛点。</li>
<li>”稳定压倒一切“：对新技术不敏感也没深入了解，要么对新技术嗤之以鼻，要么不知道有更合适的技术来解决业务问题，觉得保持现状挺好。</li>
</ul>
<p>我个人觉得，第一个问题基础设施团队相对容易犯，第二个问题业务团队相对容易犯（只是个人看法，上面的问题我都犯过，现在也在不断自省，提醒自己不能迷恋”新技术“，也不能因为不了解某种技术就否定）。</p>
<p>因此对于业务团队，我认为能做的事情是：<strong>深入和扩充</strong>技术栈，<strong>真正</strong>用技术支撑业务。注意加粗的字，为什么要强调呢？</p>
<p>关于”深入和扩充“：在做业务开发时经常是够用就行，先尽快把业务实现，并不会深挖技术栈，也不想了解别的组是怎么实现的，但这样是不够的：</p>
<ul>
<li>深入技术栈：如果要做到极致性能，就是需要深挖所在的技术栈，不深入了解，遇到疑难问题找不到思路和问题分析，遇到业务难点不知道怎么实现和优化，导致”技术深度不够”，无论对个人成长（例如出去面试），还是公司内成长（成为技术专家，在团队内营造“信任感”）都是不利的。</li>
<li>扩充技术栈：多扩充技术栈，一方面可以从别的技术栈学习好的思想和设计，看看能不能吸收自己所用的技术栈中；另一方面，多了解其他端的实现，并不是为了全栈一个人包圆了，而是在交流沟通上更加顺畅，也能站在更全面角度选择和评估技术方案。</li>
</ul>
<p>关于”真正“：在深入和扩充技术栈后，开发同学手里有了“锤子”，特别想砸钉子，要忍住这种冲动。</p>
<ul>
<li>把自己想象成一个工匠，深入&#x2F;扩充技术栈只是往自己的工具集中增加了一种工具，工匠最主要的工作是做工艺品，要根据具体情况选用合适的工具，眼睛盯着的是工艺品，而不是工具。</li>
<li>“真正”强调的是：在深入业务之后，针对业务中的痛点，看能否从新工具中找到一样合适的。</li>
</ul>
<p>总之，通过深入和扩充技术栈，开发同学扩展了自己的工具集，可以针对业务中的痛点，用更合适的工具来解决问题，应对变化，达到“技术前瞻性”的目的。</p>
<h2 id="解决问题时多思考长期改进"><a href="#解决问题时多思考长期改进" class="headerlink" title="解决问题时多思考长期改进"></a>解决问题时多思考长期改进</h2><p>在遇到一些疑难问题时，多写总结，不能解决了就过去了，从长期角度可以看看有什么改进，这样也能保证“技术前瞻性”：</p>
<ul>
<li>例如出现了内存泄露，把泄露处的代码改了是解决了问题，但从长期改进看，能不能搞一个内存泄露检测工具？</li>
<li>例如出现了性能卡顿，优化卡顿出代码也解决了问题，但从长期改进看，需要 APM 监控和自动化压力测试等</li>
</ul>
<p>最后，我们再尝试回答最一开始的问题：</p>
<ul>
<li>什么时候需要修？跟进业务走向 + 关注人员&#x2F;组织变化 + 遇到问题时关注长期角度</li>
<li>应该修什么样的屋顶？真正深入业务，了解业务全貌 + 思考长期改进</li>
<li>用什么工具和办法修？深入和扩充技术栈，手动操作自动化，配置平台化，隔离变化</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/arts-20200615/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/arts-20200615/" class="post-title-link" itemprop="url">ARTS 20200615</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-21 23:15:05" itemprop="dateCreated datePublished" datetime="2020-06-21T23:15:05+08:00">2020-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-10 21:41:57" itemprop="dateModified" datetime="2024-11-10T21:41:57+08:00">2024-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index"><span itemprop="name">ARTS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-binary-search-tree/">Validate Binary Search Tree - LeetCode</a></p>
<p>比较简单，二叉搜索树的特性是节点的左子树小于节点的值，右子树大于节点的值。本质就是二叉树中序遍历的应用，中序遍历二叉搜索树得到的数组一定是有序的。</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2016/416/">Understanding Swift Performance - WWDC 2016 - Videos - Apple Developer</a><br>没看完，主要看了 Allocation 和 Dispatch 部分，准备看完后写一个 Swift 性能相关的文章，嗯，下周的 Share 有了。。。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>如何从远端 Git 仓库中拉取某个制定文件：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1125476/retrieve-a-single-file-from-a-repository">git - Retrieve a single file from a repository - Stack Overflow</a></li>
<li>使用 Fastlane 快速更新 Push 证书：<code>fastlane pem -a bundle_id -u username -p &quot;password&quot; --force --development</code></li>
</ol>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a target="_blank" rel="noopener" href="https://joeshang.github.io/2020/06/20/refactor-parser-and-polymorphism/">重构技巧：Parser 与多态</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/refactor-parser-and-polymorphism/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/refactor-parser-and-polymorphism/" class="post-title-link" itemprop="url">重构技巧：Parser 与多态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-20 23:11:43" itemprop="dateCreated datePublished" datetime="2020-06-20T23:11:43+08:00">2020-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-10 21:41:57" itemprop="dateModified" datetime="2024-11-10T21:41:57+08:00">2024-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Architecture/" itemprop="url" rel="index"><span itemprop="name">Architecture</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/blog/1A323420-7A1B-4934-8D05-32B2B53AFB1F.png"></p>
<p>对于 Parser，一般我们能想到的是同一个数据流，根据协议或者格式的要求进行区分，解析成不同含义的元素。这个解析过程一般存在着复杂的条件逻辑，用于匹配协议或者格式的要求。</p>
<p>抽象一下，可以将 Parser 看成有<strong>复杂条件逻辑处理同一数据流</strong>的场景。而复杂的条件逻辑是编程中最难理解的东西之一，复杂的 if&#x2F;else 或者 switch&#x2F;case 中包含了许多细节，容易引入 Bug ，也使得修改变得麻烦。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在《重构 Refactoring》这本书中，针对上面的问题，有个技巧被称为“以多态取代条件表达式”（Replace Conditional with Polymorphism）</p>
<p><img src="/images/blog/command-comic-1.png"></p>
<p>这个技巧的核心在于，将每一条分支逻辑隔离到一个类中，用多态来承载各个类型特有的行为，“上层”或者“业务层”不再关心每一条分支的具体细节，不再事事躬亲，只作分发（Dispatch）的工作。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="JS-回调重构"><a href="#JS-回调重构" class="headerlink" title="JS 回调重构"></a>JS 回调重构</h3><p>最早的 WebViewController 在处理 JS 回调的方法是用一堆 if&#x2F;else 语句：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jsCallback:(<span class="built_in">NSString</span> *)name arguments:(<span class="built_in">NSDictionary</span> *)arguments &#123;</span><br><span class="line">	<span class="keyword">if</span> ([name isEqualToString:@“command1”]) &#123;</span><br><span class="line">		[<span class="keyword">self</span> handleCommand1:name arguments:arguments];</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([name isEqualToString:@“command2”]) &#123;</span><br><span class="line">		[<span class="keyword">self</span> handleCommand2:name arguments:arguments];</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([name isEqualToString:@“command3”]) &#123;</span><br><span class="line">		[<span class="keyword">self</span> handleCommand3:name arguments:arguments];</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([name isEqualToString:@“command4”]) &#123;</span><br><span class="line">		[<span class="keyword">self</span> handleCommand4:name arguments:arguments];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写的问题是导致 WebViewController 越来越庞大，一堆业务逻辑耦合到 WebViewController 中（例如登录通知，语音跟读的回调等），维护性变差。另外，如果想配置 WebViewController 只支持某些或者不支持某些 JS 特定的回调的话，甚至根据页面 URL 进行动态调整，也不是很干净。于是趁着 UIWebView 升级 WKWebView，做了一次重构：基于命令模式，将 JS 回调的处理抽离到一个个 Handler 中，JS 回调的名称和参数也在 Handler 中维护，WebViewController 中不再含有任何与 WebView 无关的业务逻辑，当 WebView 触发了 JS 回调后，调用 Command Manager 这个 Invoker 去调用 Command。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerCommands &#123;</span><br><span class="line">	[<span class="keyword">self</span>.commandManager registerCommand:[Command1Handler new]];</span><br><span class="line">	[<span class="keyword">self</span>.commandManager registerCommand:[Command2Handler new]];</span><br><span class="line">	[<span class="keyword">self</span>.commandManager registerCommand:[Command3Handler new]];</span><br><span class="line">	[<span class="keyword">self</span>.commandManager registerCommand:[Command4Handler new]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)jsCallback:(<span class="built_in">NSString</span> *)name arguments:(<span class="built_in">NSDictionary</span> *)arguments &#123;</span><br><span class="line">	JSCommand *command = [JSCommand commandWithName:name arguments:arguments];</span><br><span class="line">	[<span class="keyword">self</span>.commandManager handleCommand:command];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图片标注操作栈"><a href="#图片标注操作栈" class="headerlink" title="图片标注操作栈"></a>图片标注操作栈</h3><p>对于图片标注功能，支持笔迹、图片、文本、橡皮擦、套索等，同时有 Undo、Redo、ClearAll 等操作。</p>
<p>由于涉及到 Undo、Redo 操作，因此需要维护一个操作栈。基于此，需要将每种操作抽象成 Action，Action 中有 type 属性，用于描述 Action 的具体类型。同时定义 ActionManager 的类，负责维护操作栈，并基于操作栈实现 Undo、Redo 操作。</p>
<p>一开始的代码可能是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)undo &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.currentIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.currentIndex--;</span><br><span class="line">    Action *action = <span class="keyword">self</span>.actions[<span class="keyword">self</span>.currentIndex];</span><br><span class="line">    <span class="keyword">if</span> (action.type == ActionTypeStroke) &#123;</span><br><span class="line">        <span class="comment">// handle stroke</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type == ActionTypeLasso) &#123;</span><br><span class="line">        <span class="comment">// handle lasso</span></span><br><span class="line">    &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 undo&#x2F;redo 方法中，除了处理操作栈外，需要根据 Action 的不同，处理该类型 Action 在 undo 时应该做的事情。但回过头来看看 ActionManager 的职责，其没有必要了解 Action 的具体细节，因此，Action 应作为基类或者接口，定义 do&#x2F;undo 两个方法，各个子类 Action 实现 do&#x2F;undo 方法，分别在 ActionManager 在 redo&#x2F;undo 中调用。这样修改之后，ActionManager 的逻辑变得清晰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)undo &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.currentIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.currentIndex--;</span><br><span class="line">    Action *action = <span class="keyword">self</span>.actions[<span class="keyword">self</span>.currentIndex];</span><br><span class="line">    [action undo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SVG-解析库"><a href="#SVG-解析库" class="headerlink" title="SVG 解析库"></a>SVG 解析库</h3><p>最近看了下 <a target="_blank" rel="noopener" href="https://chromium.googlesource.com/skia/+/chrome/m44/src/svg/parser">Skia 中 SVG Parser 的源码</a>，虽然 Parser 中 switch 语句依然存在，但是 switch 中只是针对不同的标签（Path、Line、Rect、Circle 等）生成不同的 Element，至于如何解析 Element，由各个 Element 子类实现 Element 基类中定义的 translate 方法，负责解析出各自类型 Element 中的属性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/arts-20200608/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/arts-20200608/" class="post-title-link" itemprop="url">ARTS 20200608</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 22:15:04" itemprop="dateCreated datePublished" datetime="2020-06-14T22:15:04+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-10 21:41:57" itemprop="dateModified" datetime="2024-11-10T21:41:57+08:00">2024-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index"><span itemprop="name">ARTS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-width-of-binary-tree/">Maximum Width of Binary Tree - LeetCode</a></p>
<p>还是二叉树相关的题目，不管是否简单与否，按照模块进行训练比较成体系一些。（其实是周末带娃太累，刷不了复杂的题。。。）<br>计算二叉树的最大宽度这道题本身比较简单，主要有一个思维转换，所谓二叉树的宽度，就是每一层的节点个数，看到层，就转换为二叉树的层序遍历，使用队列，计算每一层节点个数，最后算出最大值即为二叉树的宽度</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/416/">iOS Memory Deep Dive - WWDC 2018 - Videos - Apple Developer</a></p>
<p>WWDC 2020 要来了，看了下 2018 年关于 iOS 内存的一个 Session：</p>
<h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><p>Pages Memory 和 Page Fault 没什么好说的，OS 基础知识。<br>iOS 上内存可以分成三类：</p>
<ol>
<li>Clean Memory：可以 Page Out 的内存，例如代码段</li>
<li>Dirty Memory：被 App 写入过数据的内存，例如堆、图片解码区</li>
<li>Compressed Memory：iOS 设备由于存储硬件的特性，并不会像桌面端一样进行 Swap，而是直接 Page Out。但从 iOS 7 开始，统开始采用压缩内存的办法来释放内存空间，被压缩的内存称为 Compressed Memory，再次访问时会先解压。因此，如果在收到 Memory Warning 时去释放被压缩内存，由于被解压，导致内存用的更多。。。</li>
</ol>
<p>在一些缓存数据场景，建议用 NSCache 替换 NSDictionary，因为 NSCache 会根据系统情况自动清理内存。</p>
<h3 id="内存占用分析工具"><a href="#内存占用分析工具" class="headerlink" title="内存占用分析工具"></a>内存占用分析工具</h3><p><img src="/images/blog/630C9DF7-3048-40A4-8ECE-41E3AF3D09DB.png"></p>
<ul>
<li>malloc_history：查看内存分配历史</li>
<li>leaks：查看泄漏内存</li>
<li>vmmap：查看虚拟捏成</li>
<li>heap：查看堆内存</li>
</ul>
<p>一些调试技巧：</p>
<ul>
<li>Xcode Memory Debugger 可以看内存中所有对象的内存使用情况和依赖关系</li>
<li>在 Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics 打开 Malloc Stack（Live Allocations Only），可以定位占用过大内存</li>
</ul>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图片在使用时，会将 jpg&#x2F;png&#x2F;webp 解码成 Bitmap，对于 RGBA，一个像素就是 4 字节，使用建议：</p>
<ul>
<li>使用 UIGraphicsImageRenderer 替代 UIGraphicsBeginImageContextWithOptions，iOS 12 上会自动选择格式，例如黑白图或单色，会讲 RGBA 降为 1 字节。</li>
<li>修改颜色，建议用 tintColor，不会有额外的内存开销。</li>
<li>Downsampling 图片时，一般会先解码，然后搞一个小的画布进行渲染，解码还是造成内存峰尖。因此建议使用 ImageIO 框架，CGImageSourceCreateThumbnailAtIndex 不会造成图片解码。</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li><p>如何从 UIBezierPath 中提取构造过程：<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3051760/how-to-get-a-list-of-points-from-a-uibezierpath">iOS - How to get a list of points from a UIBezierPath? - Stack Overflow</a></p>
</li>
<li><p>iOS 后台杀 App 以前一直以为只有两种情况：</p>
<ul>
<li>iOS 系统 Bug（13.2 有一波）</li>
<li>App 占用内存过多，进入后台后被另一个使用内存大户把系统内存吃光。</li>
</ul>
</li>
</ul>
<p>最近看同事的分析，发现还会有两点导致系统杀 App：</p>
<ul>
<li>出现内存泄漏：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48107801/ios-app-getting-killed-immediately-after-entering-background">memory leaks - IOS App getting killed immediately after entering background - Stack Overflow</a></li>
<li>进入后台持续访问像 Camera 或者 Shared System Database 等资源，也会导致系统把 App 干掉（<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes/preparing_your_ui_to_run_in_the_background">Preparing Your UI to Run in the Background | Apple Developer Documentation</a>）</li>
</ul>
<p>一些第三方 SDK 例如环信会导致这个问题： <a target="_blank" rel="noopener" href="http://www.easemob.com/question/13822">http://www.easemob.com/question/13822</a> ，至于环信的原因，有大佬用 Hopper 反解了 EMClient 的 -applicationDidEnterBackground: 方法，如下图。可以看到 isLoggedIn 方法，与登陆了之后才会被 kill 现象完全吻合。</p>
<p><img src="/images/blog/4373c66306b22120a4dd0493bcbbb543.png"></p>
<p>至于被 Kill 的原因，是因为其调用了 beginBackgroundTaskWithExpirationHandler，而此方法要求在 expiration 到期前调用 endBackgroundTask，需要成对调用，否则系统会杀掉 App，具体见：<br><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtaskwithexpiratio">https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtaskwithexpiratio</a></p>
<p>高级，是时候学一波逆向和 Hopper 了</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a target="_blank" rel="noopener" href="https://joeshang.github.io/2020/06/14/refactor-multiplexer-and-indirectional-layer/">重构技巧：数据选择器与中间层</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/refactor-multiplexer-and-indirectional-layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/refactor-multiplexer-and-indirectional-layer/" class="post-title-link" itemprop="url">重构技巧：数据选择器与中间层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 21:20:46" itemprop="dateCreated datePublished" datetime="2020-06-14T21:20:46+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-10 21:41:57" itemprop="dateModified" datetime="2024-11-10T21:41:57+08:00">2024-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Architecture/" itemprop="url" rel="index"><span itemprop="name">Architecture</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/blog/cs-of-luxun.png"></p>
<blockquote>
<p>Any problem  in computer science can be solved by anther layer of indirection  </p>
</blockquote>
<p>在计算机领域有句名言：“计算机科学领域的任何问题都可以通过一个中间层来解决”，能找到很多例子：</p>
<ul>
<li>虚拟内存： 为了更好的隔离和管理内存，在程序和物理内存之间增加虚拟的内存控件作为中间层。</li>
<li>操作系统：为了防止应用程序直接（随意）访问硬件，也为了降低使用硬件的复杂度，操作系统和驱动程序来作为中间层。</li>
<li>JVM：Java 通过构造一个 JVM 虚拟机，隔离了不同平台的底层实现，使得 Java 的字节码可以多个平台上不加修改地运行。</li>
<li>其他还有很多，例如 TCP&#x2F;IP、汇编等。</li>
</ul>
<p>总之，中间层的核心思想，是通过层与层之间的接口，隔离两个层各自的细节和变化。这种间接性 Indirection 的思想除了在架构设计上得到应用，在一些需求变化导致的重构场景也比较适合，这类场景我称为“多路开关”，或者也可以叫“数据选择器”，具体请看下面。</p>
<h2 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h2><p>在电子技术（特别是数字电路）中，数据选择器（Data Selector），或称多路复用器（multiplexer，简称：MUX），是一种可以从多个模拟或数字输入信号中选择一个信号进行输出的器件。</p>
<p><img src="/images/blog/Multiplexer2.png"></p>
<p>在软件开发中，多个输入对应一个输出的场景也比较常见：列表页原来只使用一种类型的数据，在 TableView 的 DataSource 中都是直接使用对应的 Model，随着需求变化，多了一种类型数据，而 Cell 样式是相同的。</p>
<p>此时应该如何修改代码来比较稳的应对这样的变化？直接改吗？那原来使用数据的地方会多一堆 if&#x2F;else 条件语句，难以维护不易读，如果再增加一条数据源，数据使用的地方还需要再次改动。。。</p>
<p>这类场景，和数字电路中的数据选择器类似，多路数据输入一路数据输出，由选择器负责切换数据输入。参考相同思路，也构造“数据选择器”：</p>
<ol>
<li>抽取中间层，构造“选择器”，重构原有代码接入选择器。抽象层可以用数据抽象，也可以用一个函数封装获取数据的方法，并将“选择器”相关的代码集中到一起，方便维护和处理。</li>
<li>测试重构后的代码。由于第一步是通过抽取中间层构造“选择器”，数据的消费方不再是直接访问原来的数据，而是通过“选择器”获取数据，因此需要进行测试，保证没有重构出问题，那下一步接入新数据出现问题，就是“选择器”在选择时有问题。</li>
<li>接入新的数据源。基于前面的重构，这一步的接入变得简单，专注于在“选择器”代码中根据业务需求选择走哪条数据源，数据消费部分的代码和逻辑完全不需要修改，同时选择器的选择逻辑也可以抽出来进行单测。</li>
</ol>
<h3 id="快速投票模块"><a href="#快速投票模块" class="headerlink" title="快速投票模块"></a>快速投票模块</h3><p>直播教室内的快速投票原来是基于 Ballot 命令进行显示消失的，后来服务器换成 WidgetState 的方案，相当于一条新的数据源，并且服务器期望根据 Config 配置到底使用哪条数据源。</p>
<p>重构就是分三步走：</p>
<ol>
<li>将原来直接使用 Ballot 的地方抽到函数中，并将 Ballot 和 WidgetState 中共同使用的数据抽出来，使用无依赖的基础数据类型描述（例如 bool 或字典等），原来直接用 Ballot 的消费方，现在使用这些基础数据类型。</li>
<li>测试第一步的重构。</li>
<li>接入 WidgetState 的数据，在第一步的函数中，根据 Config 决定是从 Ballot 转还是从 WidgetState 转。</li>
</ol>
<h3 id="笔迹库重构"><a href="#笔迹库重构" class="headerlink" title="笔迹库重构"></a>笔迹库重构</h3><p>以前笔迹库只渲染笔迹，所有的操作栈（Undo、Redo、Lasso、ClearScreen）等都和笔迹 View 绑定较死，现在由于要接入图形，是一个新的数据源。</p>
<p>重构依然是分三步走：</p>
<ol>
<li>将操作栈从笔迹 View 中抽出，由一个专门的 Manager 来负责管理，并生成每一步的渲染数据，笔迹 View 就负责渲染笔迹相关的数据。</li>
<li>测试第一步的重构。</li>
<li>在 Manager 中接入图形数据，并实现一个图形 View 负责渲染图形相关的数据。</li>
</ol>
<p>同时，为了保证上线的稳定性，需要有开关回退，那新旧两个 View 都在，根据开关进行区分，又是一个“数据选择器”。于是抽象一个 Protocol 做为中间层，外部使用是 UIView<Protocol>，由这个中间 View 根据开关切换。</p>
<p>最后来回顾一下所谓的“选择器“，这有什么新的东西吗？仔细看下“选择器”代码，其实就是由于多了一路数据而导致的变化，抽取中间层相当于将变化隔离开，嗯，最后还是“隔离变化”，万变不离其宗。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/arts-20200526/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/arts-20200526/" class="post-title-link" itemprop="url">ARTS 20200526</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 17:06:31" itemprop="dateCreated datePublished" datetime="2020-05-31T17:06:31+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-10 21:41:57" itemprop="dateModified" datetime="2024-11-10T21:41:57+08:00">2024-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index"><span itemprop="name">ARTS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/">Invert Binary Tree - LeetCode</a></p>
<p>决定从递归思想 + 树开始练习，周末家里有突发情况，所以选了一道简单+“有名”的翻转二叉树。树的结构由于自带子节点，所以很适合递归思想，对于这道题，翻转二叉树就是递归交换子树，递归起来可以有两种思路：</p>
<ol>
<li><p>每次交换的是左右子树，至于左右子树的结果，调用 invertTree 获取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *tmp = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        root-&gt;left = <span class="built_in">invertTree</span>(root-&gt;right); </span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每次交换左右子节点，然后再递归调用左右子节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a target="_blank" rel="noopener" href="https://www.essentialdeveloper.com/articles/why-ios-developers-feel-stuck-in-their-careers-and-what-to-do">Why iOS Developers Feel Stuck In Their Careers &amp; What To Do — Essential Developer</a></p>
<p>对于目前阶段的我而言，一直处于焦虑之中，一方面随着工作年限变多，无论是自己还是“业界”，对于自己的要求变得更高，另一方面，iOS 或者客户端相对服务器端而言，离业务有点远，核心竞争力并不突出。看到这篇文章，没想到”浓眉大眼“ Work Life Balance 的国外 iOS 同行也会 Feel Stuck。。。</p>
<p>文章的核心观点和我的看法是：</p>
<ul>
<li>不要过于急功近利，设置不切实际的目标。学习的过程是曲折向上的，需要花时间持续投入，不要期望有立竿见影的效果，先坚持一段时间再说（例如 ARTS 活动）。</li>
<li>Feeling Stuck 的原因有时候和工作环境有关，有些事可以缓解，例如同优秀的人合作（remarkable people），例如团队中有 mentor 可以指导如何高效的写和维护高质量的代码等等。关于环境这块我是这样想的，虽然环境会影响人，但个人是可以潜移默化影响环境的，要做“催化剂”</li>
<li>将工作中遇到的挑战与技术成长结合起来。工作不仅仅是编程或者技术本身，即使是一个简单的需求，那如何在 Commit 拆分上更清楚，如果是重复劳动，能否有一些自动化的工具来提高效率？在遇到例如网络超时问题时，能否更深入的排查，使用 Charles + WireShark 工具，重新翻看 TCP&#x2F;IP 等书籍查漏补缺？另外，软技能一样重要，沟通能力、领导力等，也可以提高。</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>当 UILabel 的 adjustsFontSizeToFitWidth 为 YES 时，UILabel 会根据内容多少来调整字体大小，但是此时 baseline 不变，会导致文字在 Y 轴不居中。解决办法是：将 baselineAdjustment 设置为 UIBaselineAdjustmentAlignCenters。</li>
<li>UIScrollView 的 directionalLockEnabled 能够锁死每次滑动只影响一个方向，但是当滑动是对角线的情况，就失效了，需要在 beganDragging 时记录初始 offset，并将 direction 初始化为 .none，在 DidScroll 时判断 direction 类型，并根据 vertical 或 horizontal 来设置 contentOffset，最后在 DidEndDecelerating 和 DidEndDragging（willDecelerate 为 false）时重置为 .none</li>
<li>Swift 会对其符号进行修饰（Name Mangling），具体原理见：<a target="_blank" rel="noopener" href="https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html">mikeash.com: Friday Q&amp;A 2014-08-15: Swift Name Mangling</a>。在 Bugly 上，如果崩溃在 Swift 方法中，被修饰过的命名就很难读了。Xcode 提供了对 Swift 符号进行 demangling 的工具，在命令行输入 <code>xcrun swift-demangle</code>之后，将对应的 Swift 符号拷入，点回车，就能看到解析后的结果了</li>
</ol>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a target="_blank" rel="noopener" href="https://joeshang.github.io/2020/06/14/cname-explain/">CNAME 有什么用？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/cname-explain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="尚传人">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="传人的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/cname-explain/" class="post-title-link" itemprop="url">CNAME 有什么用？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 17:01:44" itemprop="dateCreated datePublished" datetime="2020-05-30T17:01:44+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-10 21:41:57" itemprop="dateModified" datetime="2024-11-10T21:41:57+08:00">2024-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前一直好奇，公司用的 CDN 是公司域名，是如何转到阿里云或者腾讯云的？后来翻看了 DNS 的一些知识，发现和 CNAME 有关：</p>
<p>CNAME 是 Canonical Name  的缩写，也成为别名指向。</p>
<p>DNS 中 CNAME 记录和 A 记录的区别在于，A 记录是把一个域名解析到一个 IP 地址（Address，这也是 A 记录名字的原因），CNAME 记录是把一个域名解析到另一个域名，相当于加了一个中间层。</p>
<p>通过 dig 能看到 DNS 域名解析的过程，具体见：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/06/dns.html">https://www.ruanyifeng.com/blog/2016/06/dns.html</a></p>
<p>CNAME 有什么用？有句话是”在软件开发中，没有什么是加一个中间层搞不定的，如果不行，就再加一层“，哈哈，开个玩笑。CNAME 加中间层的好处是：</p>
<ul>
<li>多个域名都指向同一个别名，当 IP 变化时，只需要更新该别名的 IP 地址（A 记录），其他域名不需要改变</li>
<li>有的域名不属于自己，例如 CDN 服务，服务商提供的就是一个 CNAME，将自己的 CDN 域名绑定到 CNAME 上，CDN 服务提供商就可以根据地区、负载均衡、错误转移等情况，动态改别名的 A 记录，不影响自己 CDN 到 CNAME 的映射。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="尚传人"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">尚传人</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/joeshang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;joeshang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shangchuanren@gmail.com" title="E-Mail → mailto:shangchuanren@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/2464216170" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;2464216170" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/bridge_joe" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;bridge_joe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">尚传人</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
